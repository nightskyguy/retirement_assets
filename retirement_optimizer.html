<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retirement Optimizer V6t</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<link rel="stylesheet" href="retirementopt_styles.css">
	<base target="_blank">	
	<script src="retirement_optimizer_longtext.js"></script>	
</head>
<body>

<div class="container">
    <div class="sidebar">
        <div class="input-group">
            <select id="stratMode" onchange="toggleStratUI()">
                <option value="baseline">Withdraw to meet spend</option>
                <option value="fixed">Reduce IRA in &#120393; Years</option>
                <option value="bracket">Fill Federal Tax Bracket</option>
                <option value="minlimit">ðŸ›‘Lesser of IRMAA or TaxBracket</option>
            </select>
        </div>
        <div id="ui-fixed" class="input-group hidden">
            <label>Target Years (&#120393;)</label>
            <input type="number" id="nYears" value="10">
        </div>
        <div id="ui-bracket" class="input-group hidden">
            <label>Fill Bracket Up To:</label>
            <select id="stratRate">
                <option value="12">12%(100/50)k</option>
                <option value="22">22%(211/105)k</option>
                <option value="24" selected>24%(403/201)k</option>
                <option value="32">32%(512/256)k(</option>
                <option value="35">35%(768/640)k)</option>
            </select>
        </div>
        <div class="row"><label title="This is the goal to draw the total IRAs down to.">IRA Reduction Goal</label>
            <input type="number" id="iraBaseGoal" value="150000">
		</div>	
        <h3>1. Profile & Ages</h3>
        <div class="row">
            <div><label>Your Birth Year</label><input type="number" id="birthyear1" value="1960"></div>
            <div><label>Life Expectancy</label><input type="number" id="die1" value="88"></div>
        </div>
        <div class="row">
            <div><label>Spouse Birth Year</B></label><input type="number" id="birthyear2" value="1952"></div>
            <div><label>Spouse Life Expectancy</label><input type="number" id="die2" value="98"></div>
        </div>

        <h3>2. Assets</h3>
        <div class="row">
            <div><label>Your IRA</label>  <input type="number" id="balIRA1" value="2000000"></div>
            <div><label>Spouse IRA</label><input type="number" id="balIRA2"  value="400000"></div>
        </div>
        <div class="row">
            <div><label>Brokerage</label><input type="number" id="balBrokerage" value="400000"></div>
            <div><label>Brokerage Basis</label><input type="number" id="basisBrokerage" value="200000"></div>
        </div>
        <div class="row">
            <div><label>Roth IRA</label><input type="number" id="balRoth" value="200000"></div>
            <div><label>Cash Balance</label><input type="number" id="balCash" value="100000"></div>
        </div>

        <h3>3. Income & Spend</h3>
        <div class="row">
            <div><label>Your Social Security Amt</label><input type="number" id="ss1" value="48000"></div>
            <div><label>Start Age</label><input type="number" id="ss1Age" value="70"></div>
        </div>
        <div class="row">
            <div><label>Spouse SS Amt</label><input type="number" id="ss2" value="29000"></div>
            <div><label>Spouse Start Age</label><input type="number" id="ss2Age" value="70"></div><BR>
        </div>
        <div class="row">
            <div><label>Your Pension</label><input type="number" id="pensionAnnual" value="16900"></div>
            <div><label>Survivorship</label><input type="number" id="survivorPct" value="75">%</div>
        </div>
        <div class="row">
            <div><label>After-Tax Spending Goal</label>
            <input type="number" id="spendGoal" value="180000" class="highlight-input"></div>
            <div><label title="Most retirees follow a spending smile where each year they spend less than the prior year. 98% means you spend 2% less each year. 100 means no change.">Spending Delta </label>
            <input type="number" id="spendChange" value="99.5">% (100 means no change)</div>
		</div>

        <h3>4. Assumptions</h3>
        <div class="row">
            <div><label><A HREF="https://www.investopedia.com/inflation-rate-by-year-7253832" target="_blank">Inflation</A> (3?)</label><input type="number" id="inflation" value="0">%</div>
            <div><label><A HREF="https://www.bls.gov/regions/mid-atlantic/data/consumerpriceindexhistorical_us_table.htm" target="_blank">CPI</A>/<A HREF="https://www.fool.com/retirement/social-security/cola-history/" target="_blank">COLA</A> (2.8?)</label><input type="number" id="cpi" value="0">%</div>
        </div>
        <div class="row">
            <div><label title="Your asset mix will dictate what growth rate to expect. In a brokerage, your basis doesn't grow at the rate the account does.">Growth (6?)</label><input type="number" id="growth" value="6.0">%</div>
            <div><label title="What does your HYSA and/or Mutual fund produce annually?">Cash Interest (2.5)?</label><input type="number" id="cashYield" value="3.0">%</div>
        </div>
        <div class="row">
			<div><label title="This is the rate that your asset mix emits dividends.">Dividend Rate (0.5)?</label><BR><input type="number" id="dividendrate" value="0.5">%</div>
		</div>
        <div class="row">
			<div><label>ðŸ›‘Social Security Fail</label> <input type="number" id="ssFailYear" value="2033"></div>
            <div><label>ðŸ›‘SSecurity Reduction </label><input type="number" id="ssFailPct" value="77.3">%</div>
        </div>

    </div>

    <div class="main">
			<div class="header-drawers">
			<details class="top-drawer"><summary>Change Log</summary><div><br>
				<div class="log-entry">
				<strong id="testsFailed">ðŸŸ¢</strong></div>
				<ul>
				<li><b>6t</b> Solved a math issue causing NaN to occur. Cleaned up the visuals.
				</li>				
				<li><b>6s</b> Some more fancy highlighting of the tables. Fixed broken strategy changer. Tests moved into separate file, too.
				</li>				
				<li><b>6r</b> Moved the heavy text (top drawers) into a separate file.
				</li>
				<li><b>6q</b> Beautifications and hover notes. More self tests with an indicator on screen if they fail. Started the Social Security "meltdown" implementation. Added (empty) Insights tab.
				</li><li><b>6p</b> Corrected instructions for Single filer usage. Fixed error in brokerage tracking. Added brokerage dividend rate. Dividends automatically accrue to Cash.
				</li><li><strong>6n</strong> Calculation fixes. WARNING: detailed calculations not done - but current calcs are accurate.
				</li><li><strong>6m</strong> More self tests, some rework.
				</li><li><strong>6k</strong> Reworked tax brackets for sanity ease of update. Added more instructions. 
				</li><li><strong>6j</strong> Move style sheet out for readability.
				</li><li><strong>6i</strong> Remove the Recalculate and Optimize buttons. Use the similarly named tabs as the buttons. 
				</li><li><strong>5hp</strong> Integrated Federal SS "Tax Torpedo" logic, California HSA add-backs, and IRMAA cliff surcharges. This logic is present, but not yet being used.  The older logic is "close".
				</li><li><strong>5h</strong> Added change log and instructions
				</li><li><strong>4g</strong> Do rate limit lookups based on inflation. Add suggested values.
				</li><li><strong>4f</strong> Use cpi% to adjust taxation (brackets)
				</li><li><strong>4e</strong> Use calculated birthyear for correct RMDs
				</li>
				</ul>
				</div>
			</details>

			<details class="top-drawer">
				<summary>How to Use</summary><div class="drawer-content" id="drawer-howto"></div>
			</details>
			<details class="top-drawer"><summary>Planned</summary><div class="drawer-content" id="drawer-planned"></div>
			</details>
			<details class="top-drawer"><summary>Background</summary><div class=drawer-content" id="drawer-background"></div>
			</details>
		</div>	
        <div class="top-bar">
            <div id="summary-stats" style="display:flex; gap:30px;">
				<div><small>Years of Life</small><br><strong id="stat-years">0</strong></div>
				<div><small>Funded Years</small><br><strong id="stat-yearsfunded">0</strong></div>
                <div><small>LIFETIME TAX RATE</small><br><strong id="stat-rate">0%</strong></div>
                <div><small>TOTAL TAX</small><br><strong id="stat-tax">$0</strong></div>
                <div><small>TOTAL Spendable</small><br><strong id="stat-spend">$0</strong></div>
                <div><small>FINAL WEALTH</small><br><strong id="stat-nw">$0</strong></div>
               
            </div>
            </div>

        <div class="tabs">
            <button id="btn-tbl" class="tab-btn active" onclick="{runSimulation(); showTab('tab-tbl')}">Annual Details</button>
            <button id="btn-cht" class="tab-btn" onclick="{runSimulation(); showTab('tab-chart')}">Chart</button>
            <button id="btn-opt" class="tab-btn" onclick="{showTab('tab-insight')}">ðŸ›‘Show Insights</button>
            <button id="btn-opt" class="tab-btn" onclick="{runOptimizer(); showTab('tab-opt')}">Optimizer</button>

        </div>
		<div id="tab-insight" class="card hidden">
			Some pithy insights will appear here. Right now it's not implemented.
			<h4>Where is the Code</h4>
			This might be useful to know: you can run this locally (download the 3 pieces from github) 
			<A HREF="https://github.com/nightskyguy/retirement_assets">https://github.com/nightskyguy/retirement_assets</a>.
			<p>And you can also take a look at the source, make comments, or even open a pull request to propose changes. Just follow the link above.

			You can also directly <strong>run</strong> the code from github: <A HREF="https://nightskyguy.github.io/retirement_assets/retirement_optimizer.html">nightskyguy.github.io/retirement_assets/retirement_optimizer.html</a>
			
			<p>If you're wondering whether you're being tracked, the answer is no. There is no logic 
			(currently) to do any kind of tracking or telemetry. You can read the code if you're skeptical.
			And by the way, you SHOULD be skeptical.

			<table id="insights-table">
				<thead>
					<tr id="groupRow"></tr>
					<tr id="headerRow"></tr>
				</thead>
				<tbody id="tableBody"></tbody>
			</table>
		</div>


		<div id="tab-tbl" class="card table-wrap">
			<table id="main-table">
				<thead>
					<tr id="groupRow"></tr>
					<tr id="headerRow"></tr>
				</thead>
				<tbody id="tableBody"></tbody>
			</table>
		</div>

        <div id="tab-chart" class="card hidden">
            <canvas id="chartAssets" style="max-height:350px;"></canvas>
            <hr>
            <canvas id="chartTaxSpend" style="max-height:350px;"></canvas>
        </div>

        <div id="tab-opt" class="card hidden table-wrap">
            <table id="opt-table">
                <thead>
                    <tr>
                        <th>Strategy</th>
                        <th>Total Lifetime Tax</th>
                        <th>Final Wealth</th>
                        <th>Effective Tax Rate</th>
                        <th>Years Funded</th>
						<th>Success/Fail</th>
						<th>Years Tested</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // document.getElementById('drawer-changelog').innerHTML = drawerContent.changelog;
    document.getElementById('drawer-howto').innerHTML = drawerContent.howToUse;
    document.getElementById('drawer-planned').innerHTML = drawerContent.planned;
    document.getElementById('drawer-background').innerHTML = drawerContent.background;
});


/** TAX CONSTANTS **/
const TAXData = {
	TEST: {
		// Data used for testing only.
		YEAR: 2026,
		MFJ: { std: 100, brackets: [{l: 1000, r: 0.1},  {l: 2000, r: 0.2}, {l: 40000, r: 0.8} ]	},
		SGL: { std: 100/2, brackets: [{l: 1000/2, r: 0.1},  {l: 2000/2, r: 0.2}, {l: 40000/2, r: 0.8} ]}
	},
    STATE: {
		YEAR: 2025,
        MFJ: {
            std: 10804,
            brackets: [
                { l: 20824, r: 0.01 }, { l: 49368, r: 0.02 }, { l: 77918, r: 0.04 },
                { l: 108162, r: 0.06 }, { l: 136700, r: 0.08 }, { l: 698274, r: 0.093 },
                { l: 837922, r: 0.103 }, { l: 1000000, r: 0.123 }, { l: 1e9, r: 0.133 }
            ]
        },
        SGL: {
            std: 5402,
            brackets: [
                { l: 10412, r: 0.01 }, { l: 24684, r: 0.02 }, { l: 38959, r: 0.04 },
                { l: 54081, r: 0.06 }, { l: 68350, r: 0.08 }, { l: 349137, r: 0.093 },
                { l: 418961, r: 0.103 }, { l: 698271, r: 0.123 }, { l: 1e9, r: 0.133 }
            ]
        }
    },

	FEDERAL: {
		YEAR: 2026,  // Official IRS Revenue Procedure 2025-32
		REFERENCE: 'https://www.irs.gov/newsroom/irs-releases-tax-inflation-adjustments-for-tax-year-2026-including-amendments-from-the-one-big-beautiful-bill',
		REF_2: 'https://taxfoundation.org/data/all/federal/2026-tax-brackets/',
		MFJ: {
			std: 32200, 
			age: 65,
			stdbump: 1650,
			brackets: [ 
				{ l: 24800, r: 0.10 }, 
				{ l: 100800, r: 0.12 }, 
				{ l: 211400, r: 0.22 },
				{ l: 403550, r: 0.24 }, 
				{ l: 512450, r: 0.32 }, 
				{ l: 768700, r: 0.35 },
				{ l: 1e9, r: 0.37 }	]
			},
		SGL: {
			std: 16100,
			age: 65,
			stdbump: 2050,
			brackets: [
				{ l: 12400, r: 0.10 }, 
				{ l: 50400, r: 0.12 }, 
				{ l: 105700, r: 0.22 },
				{ l: 201775, r: 0.24 }, 
				{ l: 256225, r: 0.32 }, 
				{ l: 640600, r: 0.35 },
				{ l: 1e9, r: 0.37 }	]
			},
		HOH: {
			std: 24150,
			age: 65,
			stdbump: 2050,
			brackets: [
				{ l: 17700, r: 0.10 }, 
				{ l: 75350, r: 0.12 }, 
				{ l: 160600, r: 0.22 },
				{ l: 213000, r: 0.24 }, 
				{ l: 265700, r: 0.32 }, 
				{ l: 580250, r: 0.35 },
				{ l: 1e9, r: 0.37 }	]
			},
		},
		
	FED_CAP_GAINS: {
		YEAR: 2026,
		REFERENCE: 'none - Claude.ai created it.',
		NOTE: 'This bracket combines capital gains and NIIT - strictly speaking its not correct', 
		MFJ: {
			brackets: [
				{ l: 98900, r: 0.00 },      // 0% cap gains
				{ l: 250000, r: 0.15 },     // 15% cap gains, no NIIT
				{ l: 613700, r: 0.188 },    // 15% + 3.8% NIIT = 18.8%
				{ l: 1e9, r: 0.238 }        // 20% + 3.8% NIIT = 23.8%
			]
		},
		SGL: {
			brackets: [
				{ l: 49450, r: 0.00 },      // 0% cap gains
				{ l: 200000, r: 0.15 },     // 15% cap gains, no NIIT
				{ l: 306850, r: 0.188 },    // 15% + 3.8% NIIT = 18.8%
				{ l: 1e9, r: 0.238 }        // 20% + 3.8% NIIT = 23.8%
			]
		}
	},
	
	SOCIALSECURITY: {
		Year: 2025,
		MFJ: { brackets: [{ l:32000-1, r: 0.0}, { l:32000, r: 0.5}, {l: 44000, r: 0.85}] },
		MFJ: { brackets: [{ l:32000-1, r: 0.0}, { l:32000, r: 0.5}, {l: 44000, r: 0.85}] }
		},

	IRMAA: {
		YEAR: 2026,
		LOOKBACK: 2024,  // Based on 2024 tax return
		standardPartB: 202.90,
		partBDeductible: 283,
		
		MFJ: {
			brackets: [
				{ l: 218000 - 1, r: 0}, 
				{ l: 218000, r: (2 * 202.90) },
				{ l: 274000, r: 2 * (284.10 + 14.50) },
				{ l: 348000, r: 2 * (405.90 + 37.60) },
				{ l: 410000, r: 2 * (527.70 + 60.60) },
				{ l: 750000, r: 2 * (649.50 + 83.70) },
				{ l: 1e9, r: 2 * (689.90 + 91.00) }
			]
		},
		
		SGL: {
			brackets: [
				{ l: 109000 - 1, r: 0}, 
				{ l: 109000, r: 202.90 +0 },
				{ l: 137000, r: 284.10 +14.50 },
				{ l: 174000, r: 405.90 + 37.60 },
				{ l: 205000, r: 527.70 + 60.60 },
				{ l: 500000, r: 649.50 + 83.70 },
				{ l: 1e9, r: 689.90 + 91.00 }
			]
		},
		
		MFS: {
			brackets: [
				{ l: 109000 - 1, r: 0}, 
				{ l: 109000, r: 202.90 + 0 },
				{ l: 403000, r: 649.50 + 83.70 },
				{ l: 1e9, r: 689.90 + 91.00 }
			]
		}
	}	
};

// Uniform Lifetime Table (Simplified)
const RMD_TABLE = {
    72: 27.4, 73: 26.5, 74: 25.5, 75: 24.6, 76: 23.7, 77: 22.9, 78: 22.0, 79: 21.1,
    80: 20.2, 81: 19.4, 82: 18.5, 83: 17.7, 84: 16.8, 85: 16.0, 86: 15.2, 87: 14.4,
    88: 13.7, 89: 12.9, 90: 12.2, 91: 11.5, 92: 10.8, 93: 10.1, 94: 9.5, 95: 8.9,
    96: 8.4, 97: 7.8, 98: 7.3, 99: 6.8, 100: 6.4, 101: 6.0, 102: 5.6, 103: 5.2,
	104: 4.9, 105: 4.6, 106: 4.3, 107: 4.1, 108: 3.9, 109: 3.7, 110: 3.5, 111: 3.4,
	112: 3.3, 113: 3.1, 114: 3.0, 115: 2.9, 116: 2.8, 117: 2.7, 118: 2.5, 119: 2.3, 120: 2.0
};

function getRMDPercentage(age, birthYear) {
const startAge = (birthYear >= 1960) ? 75 : 73;
    if (age < startAge) return 0;
    if (age > 120) return 1/RMD_TABLE[120];
    return 1/(RMD_TABLE[age]);
}

// Calculate the withdrawal rate to reduce an account from currentIRA to targetIRA
function calculateSystematicWithdrawal(currentIRA, targetIRA, years, growthRate) {
    // Amount that needs to be withdrawn
    const excessAmount = currentIRA - targetIRA;
    
    // Grow the target to its future value
    const targetFV = targetIRA * Math.pow(1 + growthRate, years);
    
    // Calculate required annual withdrawal (amortization of excess)
    const r = growthRate;
    const n = years;
    
    if (r === 0) {
        return excessAmount / n;
    }
    
    const withdrawal = excessAmount * (r * Math.pow(1 + r, n)) / (Math.pow(1 + r, n) - 1);
    
    return withdrawal;
}

// Example: $1M IRA, want to get down to $200K over 10 years, 6% growth
const withdrawal = calculateSystematicWithdrawal(1000000, 200000, 10, 0.06);


// Find the top amount in the provided brackets. If the bracket isn't found, it finds 
// the limit in the next lower bracket.  This doesn't check to be sure any values are reasonable.

function findLimitByRate( entity, status, tgtrate, inflation=1) {
    let brks = TAXData?.[entity]?.[status]?.brackets;

    let limit = 0;
	let rate = 0;
	
    for (let b of brks) {
        if (b.r <= tgtrate ) {
			limit = b.l * inflation;
			rate = b.r;
        } else break;
    }
	return { limit, rate: rate }
}


// We want to find the limit of the next bracket HIGHER than the amount given (that is the upper limit).
// For example if the limits are 10, 100, 1000 and the amount is 150 - we want the 1000 (less 1).
// If amount is 99, we want 100.
function findUpperLimitByAmount( entity, status, amount, inflation=1) {
    let limit = 0;
	let rate = 0;
	
    for (let b of TAXData?.[entity]?.[status]?.brackets) {
        if (b.l * inflation <= amount ) {
			rate = b.r;
        } else {
			limit = b.l * inflation - 1;
			break;
		}
    }
	return { limit, rate: rate }
}

let simulationCount = 0;
/** SIMULATION ENGINE **/
function simulate(inputs) {
    let balance = {
        ira1: inputs.ira1, ira2: inputs.ira2, roth: inputs.roth,
        brokerage: inputs.brokerage, basis: inputs.basis, cash: inputs.cash,
		basisBrokerage: inputs.basisBrokerage,
        magiHistory: []
    };
    simulationCount += 1;
    let log = [];
	//!!!TODO Remove hardcoded start year!
    let startYear = 2026;
	let birthyear1 = inputs.birthyear1;
	let birthyear2 = inputs.birthyear2;

    let maxYears = Math.max(inputs.birthyear1 + inputs.die1, inputs.birthyear1 + inputs.die2) - startYear + 1;
    let totals = { tax: 0, gross: 0, spend: 0, yearsfunded: 0, success: true, yearstested: 0, failedInYear: [] };

	let cpiRate = 1
	let inflation = 1
	let fixedWithdrawal = calculateSystematicWithdrawal(balance.ira1 + balance.ira2, inputs.iraBaseGoal, inputs.nYears,inputs.growth)
	let currentTaxableGuess = 0;
	let spendDelta = 1
	let spendGoal = inputs.spendGoal;
	let cumulativeTaxes = 0;
	let nominalTaxRate = 0.20; // Just a guess.
	let currentYear = startYear;


	

    for (let y = 0; y < maxYears; y++) {
		spendGoal = spendGoal * spendDelta * (1+inputs.inflation);
		
		cpiRate = (1 + inputs.cpi) * cpiRate
		inflation = (1 + inputs.inflation) * inflation
		spendDelta = inputs.spendChange;

        let age1 = startYear - birthyear1 + y;
        let age2 = startYear - birthyear2 + y;
        let alive1 = age1 <= inputs.die1;
        let alive2 = age2 <= inputs.die2;
        if (!alive1 && !alive2) break;

		totals.yearstested += 1;

        let status = (alive1 && alive2) ? 'MFJ' : 'SGL';
		
		
		// Calculate the bracket limits based on: stated limit.
		let tgtBracketLimit = findLimitByRate('FEDERAL',status,inputs.stratRate)
		
		// Find federal & state rates and limits by spending goal:
		let goalFedBracketLimit = findUpperLimitByAmount('FEDERAL', status, spendGoal , cpiRate)
		let goalStateBracketLimit = findUpperLimitByAmount('STATE', status, spendGoal, cpiRate)
		let goalLimit = Math.min(goalFedBracketLimit.limit, goalStateBracketLimit.limit)
		let irmaaBracket = findUpperLimitByAmount('IRMAA', status, goalLimit, cpiRate)
		let irmaLimit = Math.min(goalLimit, irmaaBracket.limit);
		
		//!!! TODO: if strategy is "bracket" but spendGoal is > bracket we have a problem.

        // 1. Inherit IRA
        if (!alive1 && balance.ira1 > 0) { balance.ira2 += balance.ira1; balance.ira1 = 0; }
        if (!alive2 && balance.ira2 > 0) { balance.ira1 += balance.ira2; balance.ira2 = 0; }

        // 2. Base Income
        let s1 = (alive1 && age1 >= inputs.ss1Age) ? inputs.ss1 * cpiRate : 0;
        let s2 = (alive2 && age2 >= inputs.ss2Age) ? inputs.ss2 * cpiRate : 0;
        let pen = inputs.pensionAnnual;
		
		// One is deceased (if both decease, it won't get here)
        if (!alive1 || !alive2) {
            // Survivor Logic: Max of SS + Survivorship % of Pension
            s1 = Math.max(s1, s2);
            s2 = 0;
            if (!alive1) { pen = pen * (inputs.survivorPct/100) }
        }
        let fixedInc = s1 + s2;
		let taxableInc = pen;
		let taxableInterest = balance.cash * inputs.cashYield
		let taxableDividends = balance.brokerage * inputs.dividendRate
		

        // 3. RMDs
        let rmd1 = alive1 ? balance.ira1 * getRMDPercentage(age1, birthyear1) || 0 : 0;
        let rmd2 = alive2 ? balance.ira2 * getRMDPercentage(age2, birthyear2) || 0 : 0;
		
		// Immediately remove RMDs from the respective IRAs because they MUST be taken first.
		balance.ira1 = Math.max(0, balance.ira1 - rmd1);
		balance.ira2 = Math.max(0, balance.ira2 - rmd2);
		
        let totalRMD = rmd1 + rmd2;
		taxableInc += totalRMD

        // 4. Determine Target Spending amount based on Strategy
        let targetSpend = Math.min(spendGoal, goalLimit);
        let iraWD = 0;

		//!!! Find the income federal limit. TODO: use that limit, to refine down to the next lower IRMAA limit and next lower State Limit.
		let fedRate = goalFedBracketLimit.rate
		let stateRate = goalStateBracketLimit.rate
		

        if (inputs.strat === 'fixed') {
            let remYears = Math.max(1, inputs.nYears - y);
			//!!! Doesn't have a floor to map to.
			let curIRA = balance.ira1 + balance.ira2 - inputs.iraBaseGoal;
			let amortized = fixedWithdrawal - totalRMD;
			
			//!!!TODO totalRMD has has already been removed...
            iraWD = Math.max(0, amortized);
        } else if (inputs.strat === 'bracket' || inputs.strat === 'minlimit') {
			//!!! This code has flaws.  Withdraws too much.
			let fedLimit = findLimitByRate('FEDERAL', status, inputs.stratRate, cpiRate);
			let limit = fedLimit.limit;
			fedRate = fedLimit.rate;	

			//!!!TODO Find the state rate and limit that corresponds to the limit (fedLimit.fedLimit)
			//!!!TODO Find the IRMAA limit that corresponds to the fedLimit.fedLimit
			let stLimit = findUpperLimitByAmount('STATE', status, fedLimit.limit, cpiRate);
			stateRate = stLimit.rate;
			stateLimit = stLimit.limit;
			
			// pick whatever is smaller (state or Federal limit for the amount desired)
			limit = Math.min(stateLimit, limit)
			
			if (inputs.strat === 'minlimit') {
				limit = Math.min(limit, irmaLimit)
			}
			
            currentTaxableGuess = limit - fixedInc - taxableInc - totalRMD;
            iraWD = Math.max(0, currentTaxableGuess);
        } else {
	       // Must be "baseline" strategy.  Withdraw enough to pay taxes.
		   iraWD = Math.max(0, targetSpend / (1-fedRate-stateRate) - totalRMD);
		}
        
        // Ensure we don't withdraw more than exists - we've already removed the totalRMD
        iraWD = Math.min(iraWD, balance.ira1 + balance.ira2);
		
		// if (Number.isNaN(iraWD)) {
		//   throw new Error('iraWD is NaN');
		// }

        // 5. Tax Calc (Including IRMAA lag)
		//!!!TODO Assumes capital gains is zero. Not tracking cap gains.
		//!!!TODO Must also calculate the interest gained on cash.
        let tax = calculateTax(fixedInc, iraWD + totalRMD + taxableInterest, taxableDividends, status, age1, age2, cpiRate);
		//!!! Assume MAGI for prior to years is the same as this year. Should allow this to be entered
		let magiHistoryLength = balance.magiHistory.length
		if (magiHistoryLength < 1) {
			balance.magiHistory.push(tax.magi);
			balance.magiHistory.push(tax.magi);
		}
        let irmaa = calcIRMAA(balance.magiHistory[balance.magiHistory.length-2], status, cpiRate);
        let totalTax = tax.total + irmaa;
		cumulativeTaxes += totalTax;

        // 6. Cash Flow Gap
        let netCash = (fixedInc + iraWD) - totalTax;
        let gap = targetSpend - netCash;
        
        let rothWD = 0;
        let brokerageWD = 0;
		let cashWD = 0;

        if (gap > 0) {
            // Need more money - Order: Cash -> Brokerage -> Roth
            cashWD = Math.min(gap, balance.cash);
            balance.cash -= cashWD; gap -= cashWD;
            
            if (gap > 0) {
                brokerageWD = Math.min(gap, balance.brokerage);
                balance.brokerage -= brokerageWD; 
				gap -= brokerageWD;
            }
            if (gap > 0) {
                rothWD = Math.min(gap, balance.roth);
                balance.roth -= rothWD; gap -= rothWD;
            }
            // If Gap still > 0, we take more IRA (Baseline behavior)
			// NOTE: From earlier we already know the marginal state and federal brackets.
            if (gap > 0 && (balance.ira1 + balance.ira2) > 0) {
                let extraIRA = Math.min(gap / (1-tax.fedRate+tax.stRate), balance.ira1 + balance.ira2);
                iraWD += extraIRA;
                // Re-calculate tax for new IRA WD
                tax = calculateTax(fixedInc, iraWD + totalRMD, 0, status, age1, age2, cpiRate);
                totalTax = tax.fed + tax.state + irmaa;
                netCash = (fixedInc + iraWD) - totalTax;
                gap = targetSpend - (netCash + rothWD + brokerageWD + cashWD);
            }
        } else if (gap < -100 && (inputs.strat !== 'baseline')) {
            // Surplus logic (Conversions)
            let surplus = Math.abs(gap);
            balance.roth += surplus;
			rothWD -= surplus
        }
		
		nominalTaxRate = totalTax / (fixedInc + iraWD + pen + taxableDividends + taxableInterest + 0.01)		

        // 7. Updates
		
		let netIncome = (fixedInc + pen + iraWD + rothWD + brokerageWD + cashWD) - totalTax
		
		//!!! Remove withdrawals proportionately. RMDs have already been withdrawn.
        balance.ira1 = Math.max(0, balance.ira1 - (iraWD * (balance.ira1/(balance.ira1+balance.ira2||1))));
        balance.ira2 = Math.max(0, balance.ira2 - (iraWD * (balance.ira2/(balance.ira1+balance.ira2||1))));
        balance.ira1 *= (1 + inputs.growth);
        balance.ira2 *= (1 + inputs.growth);
        balance.roth *= (1 + inputs.growth);
        balance.brokerage *= (1 + inputs.growth);
		
		// Accrue dividends to cash
        balance.cash = balance.cash * (1 + inputs.cashYield) + taxableDividends;
        balance.magiHistory.push(tax.magi);

        totals.tax += totalTax;
        totals.gross += (fixedInc + iraWD);
        totals.spend += (targetSpend - Math.max(0, gap));
		
		let totalWealth = (balance.ira1 + balance.ira2) * nominalTaxRate + balance.roth + (balance.brokerage) * nominalTaxRate + balance.cash

		if (netIncome < targetSpend || totalWealth < 10000) {
			totals.success = false;
			totals.failedInYear.push(startYear + y)
		} else {
			totals.yearsfunded += 1
		}

        log.push({
            year: startYear + y,
            age1: alive1 ? age1 : 'â€”',
            age2: alive2 ? age2 : 'â€”',
			// 'spendDelta%': spendDelta,
            spendGoal: targetSpend,
            SSincome: fixedInc,
			pension: pen,
			'-RMD1-': rmd1,
			'-RMD2-': rmd2,
            'RMDwd': -totalRMD,
            'IRAÎ”': -iraWD,
            'BrokerageÎ”': -brokerageWD,
			'-CapGains': 0,
			cashDiv: taxableDividends,
			cashInt: taxableInterest,
            'RothÎ”': -rothWD,
            'CashÎ”': -cashWD,
			// totalIncome: iraWD + rothWD + brokerageWD + cashWD + fixedInc + pen + taxableInterest + taxableDividends,
			netCash: taxableDividends + taxableInterest - cashWD,
			IRMAA: irmaa,
			FedTax: tax.fed,
			StateTax: tax.state,
            totalTax: totalTax,
            '-fedLimit': tax.fedLimit,
			'-stateLimit': tax.stLimit,
			'-fedRate%': tax.fedRate,
			'-stateRate%': tax.stRate,
			'NominalTax%': nominalTaxRate,
			'SumTaxes': cumulativeTaxes,
            IRA1Bal: balance.ira1,
			IRA2Bal: balance.ira2,
			TotalIRA: balance.ira1 + balance.ira2,
			CashBal: balance.cash,
			RothBal: balance.roth,
            brokerageBal: balance.brokerage,
            totalWealth: totalWealth,
            netIncome: netIncome
        });

    } // end large for for year by year.

    return { log, totals, finalNW: log[log.length-1].totalWealth };
}


/**
 * Finds the optimal mix of IRA withdrawals and brokerage sales to meet a target 
 * after-tax spending goal while minimizing total income (to preserve assets).
 * 
 * APPROACH:
 * Uses a two-level optimization strategy:
 * 1. Outer loop: Tests different ratios of brokerage sales vs IRA withdrawals 
 *    (0% to 100% from brokerage in 2% increments)
 * 2. Inner loop: Binary search to find the minimum gross income needed for each 
 *    ratio that achieves the after-tax spending target
 * 
 * The function accounts for:
 * - Cost basis in brokerage (only gains are taxed, not principal)
 * - 85% taxation of Social Security income (assumed based on income levels)
 * - Different tax treatment of earned income (IRA withdrawals) vs capital gains
 * - Federal, state (CA), and IRMAA Medicare surcharges
 * - Preservation of cash and Roth assets (not tapped in current implementation)
 * 
 * PARAMETERS:
 * @param {number} targetAfterTaxSpending - The desired after-tax spending amount
 * @param {Object} taxParams - Parameters for calculateTaxes function including:
 *   - yearOffset: Year offset from current year
 *   - filingStatus: 'Single', 'MFJ', 'MFS', 'HOH'
 *   - ages: [age1, age2] for IRMAA calculations
 *   - ss1, ss2: Social Security income amounts
 *   - ordDivInterest, qualifiedDiv: Investment income
 *   - taxExemptInterest: Tax-exempt interest income
 *   - pensionIncome: Pension income
 *   - hsaContrib: HSA contribution amount
 *   - cpi: CPI adjustment factor
 *   Note: earnedIncome and capGains will be overridden by this function
 * @param {number} brokerageBalance - Current total brokerage account balance
 * @param {number} brokerageBasis - Current cost basis in brokerage account
 * 
 * RETURN VALUE:
 * Returns an object with the optimal withdrawal strategy, or null if no solution found:
 * {
 *   iraWithdrawal: number,           // Amount to withdraw from IRA
 *   brokerageSale: number,           // Amount to sell from brokerage (gross proceeds)
 *   brokerageBasisReduction: number, // Amount of basis consumed (for tracking)
 *   capGainsRealized: number,        // Taxable capital gains from brokerage sale
 *   fedAGI: number,                  // Federal Adjusted Gross Income
 *   fedTax: number,                  // Federal income tax
 *   caTax: number,                   // California state income tax
 *   irmaa: number,                   // IRMAA Medicare surcharges
 *   totalTax: number,                // Sum of all taxes and surcharges
 *   effectiveRate: string,           // Effective tax rate as percentage string
 *   afterTaxSpending: number,        // Actual after-tax amount available (>= target)
 *   cashNeeded: number,              // Cash to tap (currently always 0)
 *   rothNeeded: number               // Roth to tap (currently always 0)
 * }
 * 
 * EXAMPLE:
 * const result = findRequiredWithdrawals(
 *   150000,
 *   { yearOffset: 0, filingStatus: 'MFJ', ages: [65, 63], ss1: 30000, ss2: 20000,
 *     ordDivInterest: 5000, qualifiedDiv: 3000, taxExemptInterest: 0, 
 *     pensionIncome: 0, hsaContrib: 0, cpi: 0.03 },
 *   500000,  // $500k brokerage balance
 *   250000   // $250k cost basis (50% gains)
 * );
 * // result.iraWithdrawal might be 80000
 * // result.brokerageSale might be 60000
 * // result.capGainsRealized might be 30000 (50% of sale is gain)
 */
function findRequiredWithdrawals(
  targetAfterTaxSpending,
  taxParams,
  brokerageBalance,
  brokerageBasis
) {
  
  let iterations = 0;
  // Extract all income sources from taxParams
  const { ss1, ss2, ordDivInterest, qualifiedDiv, taxExemptInterest, pensionIncome } = taxParams;
  const ssIncome = (ss1 || 0) + (ss2 || 0);
  const otherIncome = (ordDivInterest || 0) + (qualifiedDiv || 0) + (taxExemptInterest || 0) + (pensionIncome || 0);
  
  // Check if other income already meets the need
  const taxParamsOtherOnly = {
    ...taxParams,
    earnedIncome: 0,
    capGains: 0
  };
  const taxResultOtherOnly = calculateTaxes(taxParamsOtherOnly);
  iterations += 1;
  const afterTaxFromOtherOnly = ssIncome + otherIncome - taxResultOtherOnly.totalTax;
  
  if (afterTaxFromOtherOnly >= targetAfterTaxSpending) {
    // No additional withdrawals needed
    return {
      iraWithdrawal: 0,
      brokerageSale: 0,
      brokerageBasisReduction: 0,
      capGainsRealized: 0,
      fedAGI: taxResultOtherOnly.fedAGI,
      fedTax: taxResultOtherOnly.fedTax,
      caTax: taxResultOtherOnly.caTax,
      irmaa: taxResultOtherOnly.irmaa,
      totalTax: taxResultOtherOnly.totalTax,
      effectiveRate: taxResultOtherOnly.effectiveRate,
      afterTaxSpending: Math.round(afterTaxFromOtherOnly),
      cashNeeded: 0,
      rothNeeded: 0
    };
  } // end if afterTaxFromOtherOnly >= targetAfterTaxSpending
  
  const gainRatio = 1 - (brokerageBasis / brokerageBalance);
  
  let bestSolution = null;
  let minTotalIncome = Infinity;
  
  // Try different splits: 0% to 100% from brokerage (rest from IRA)
  for (let brokeragePct = 0; brokeragePct <= 100; brokeragePct += 2) {
    
    let low = targetAfterTaxSpending - afterTaxFromOtherOnly;  // Adjust starting point
    let high = (targetAfterTaxSpending - afterTaxFromOtherOnly) * 2;
    
    // Binary search on total gross income needed
    while (high - low > 1) {
      let totalGrossNeeded = (low + high) / 2;
      
      let fromBrokerage = totalGrossNeeded * (brokeragePct / 100);
      let capGains = fromBrokerage * gainRatio;
      let fromIRA = totalGrossNeeded * (1 - brokeragePct / 100);
      
      const currentTaxParams = {
        ...taxParams,
        earnedIncome: fromIRA,
        capGains: capGains
      };
      
      const taxResult = calculateTaxes(currentTaxParams);
		iterations += 1;
	  
      
      // Include all income sources
      let afterTax = totalGrossNeeded + ssIncome + otherIncome - taxResult.totalTax;
      
      if (afterTax < targetAfterTaxSpending) {
        low = totalGrossNeeded;
      } else {
        high = totalGrossNeeded;
      } // end if afterTax < targetAfterTaxSpending
    } // end while (binary search)
    
    let totalGrossNeeded = high;
    let fromBrokerage = totalGrossNeeded * (brokeragePct / 100);
    let fromIRA = totalGrossNeeded * (1 - brokeragePct / 100);
    let capGains = fromBrokerage * gainRatio;
    
    const currentTaxParams = {
      ...taxParams,
      earnedIncome: fromIRA,
      capGains: capGains
    };
    
    const taxResult = calculateTaxes(currentTaxParams);
    iterations += 1;

    let afterTax = totalGrossNeeded + ssIncome + otherIncome - taxResult.totalTax;
    
    // Verify solution works and is better
    if (afterTax >= targetAfterTaxSpending && totalGrossNeeded < minTotalIncome) {
      minTotalIncome = totalGrossNeeded;
      
      let brokerageBasisUsed = fromBrokerage * (brokerageBasis / brokerageBalance);
      
      bestSolution = {
	    iterations: iterations,
        iraWithdrawal: Math.round(fromIRA),
        brokerageSale: Math.round(fromBrokerage),
        brokerageBasisReduction: Math.round(brokerageBasisUsed),
        capGainsRealized: Math.round(capGains),
        fedAGI: taxResult.fedAGI,
        fedTax: taxResult.fedTax,
        caTax: taxResult.caTax,
        irmaa: taxResult.irmaa,
        totalTax: taxResult.totalTax,
        effectiveRate: taxResult.effectiveRate,
        afterTaxSpending: Math.round(afterTax),
        cashNeeded: 0,
        rothNeeded: 0
      };
    } // end if (verify solution)
  } // end for brokeragePct
  
  return bestSolution;
} // end findRequiredWithdrawals

/**
 * Calculates Federal, California State, and IRMAA taxes.
 * * @param {Object} params - Input parameters
 * @param {number} params.yearOffset - Number of years from base (2026) to adjust for cpi/Inflation.
 * @param {string} params.filingStatus - 'MFJ' (Married Filing Jointly) or 'Single'.
 * @param {Array}  params.ages - Array of ages [age1, age2] or [age1] if single.
 * @param {number} params.earnedIncome - Total of W2, IRA/401k withdrawals, and RMDs.
 * @param {number} params.ss1 - Social Security for Person 1.
 * @param {number} params.ss2 - Social Security for Person 2 (0 if Single).
 * @param {number} params.ordDivInterest - Interest and Ordinary Dividends.
 * @param {number} params.qualifiedDiv - Qualified Dividends (taxed at lower rates Federally).
 * @param {number} params.capGains - Net Long Term Capital Gains.
 * @param {number} params.taxExemptInterest - Muni bond interest (non-taxable but used for SS/IRMAA/CA).
 * @param {number} params.hsaContrib - Total HSA contributions (deductible Fed, taxable CA).
 * @param {number} params.cpi - Annual cpi/Inflation rate (e.g., 0.025 for 2.5%).
 */
function calculateTaxes(params) {
    const { 
        yearOffset, filingStatus, ages, earnedIncome, ss1, ss2, 
        ordDivInterest, qualifiedDiv, capGains, taxExemptInterest, 
        hsaContrib, cpi 
    } = params;

    const inflationFactor = Math.pow(1 + cpi, yearOffset);
    const totalSS = ss1 + ss2;

    // --- 1. FEDERAL SOCIAL SECURITY TAXABILITY ---
    // Formula: Provisional Income = AGI (excluding SS) + TaxExemptInterest + 50% of SS
    const provisionalIncome = earnedIncome + ordDivInterest + qualifiedDiv + capGains + taxExemptInterest - hsaContrib + (totalSS * 0.5);
    
    let taxableSS = 0;
	//!!! TODO This logic can be replace with calculateProgressive using the provisionalIncome?!
	taxableSS = calculateProgressive('SOCIALSECURITY', filingStatus, provisionalIncome, inflationFactor).cumulative
    const ssThreshold1 = (filingStatus === 'MFJ' ? 32000 : 25000) * inflationFactor;
    const ssThreshold2 = (filingStatus === 'MFJ' ? 44000 : 34000) * inflationFactor;

    if (provisionalIncome > ssThreshold2) {
        taxableSS = Math.min(0.85 * totalSS, (0.85 * (provisionalIncome - ssThreshold2)) + Math.min(6000 * inflationFactor, 0.5 * (ssThreshold2 - ssThreshold1)));
    } else if (provisionalIncome > ssThreshold1) {
        taxableSS = Math.min(0.5 * totalSS, 0.5 * (provisionalIncome - ssThreshold1));
    }

    // --- 2. FEDERAL TAX CALCULATION ---
    const fedAGI = earnedIncome + ordDivInterest + qualifiedDiv + capGains + taxableSS - hsaContrib;
    
    // Standard Deduction with Age 65+ bump
    let fedStdDeduct = TAXData['FEDERAL'][filingStatus].std * inflationFactor;
    ages.forEach(age => { if (age >= TAXData['FEDERAL'][filingStatus].age) fedStdDeduct += (TAXData['FEDERAL'][filingStatus].stdbump * inflationFactor); });

    const fedTaxableIncome = Math.max(0, fedAGI - fedStdDeduct);
    const prefIncome = qualifiedDiv + capGains; // Income taxed at 0/15/20%
    const ordinaryTaxable = Math.max(0, fedTaxableIncome - prefIncome);

    const fedOrdinaryTax = calcProgressive(ordinaryTaxable, getFedBrackets(filingStatus, inflationFactor));
	let testFedTax = calculateProgressive('FEDERAL', filingStatus, ordinaryTaxable, inflationFactor).cumulative
    const fedPrefTax = calcPrefTax(ordinaryTaxable, prefIncome, filingStatus, inflationFactor);
    const totalFedTax = fedOrdinaryTax + fedPrefTax;

    // --- 3. (CALIFORNIA) STATE TAX CALCULATION ---
    // CA Add-backs: HSA is taxable. Muni interest is taxable (assuming out-of-state for conservative estimate).
    // CA Subtractions: Social Security is 100% exempt.
    const caAGI = (fedAGI - taxableSS) + hsaContrib + taxExemptInterest;
    const caStdDeduct = TAXData['STATE'][filingStatus].std * inflationFactor;
    const caTaxableIncome = Math.max(0, caAGI - caStdDeduct);
    const caTax = calcProgressive(caTaxableIncome, getCABrackets(filingStatus, inflationFactor));
	let testCAResult = calculateProgressive('STATE', filingStatus, caTaxableIncome, inflationFactor).cumulative
	

    // --- 4. IRMAA CALCULATION ---
    // MAGI for IRMAA = Fed AGI + Tax-Exempt Interest
    const irmaaMAGI = fedAGI + taxExemptInterest;
    const irmaaAnnualSurcharge = calcIRMAA(irmaaMAGI, filingStatus, inflationFactor) * 12;

    return {
        fedAGI: Math.round(fedAGI),
        fedTax: Math.round(totalFedTax),
        caTax: Math.round(caTax),
        irmaa: Math.round(irmaaAnnualSurcharge),
        totalTax: Math.round(totalFedTax + caTax + irmaaAnnualSurcharge),
        effectiveRate: ((totalFedTax + caTax + irmaaAnnualSurcharge) / (fedAGI + totalSS + taxExemptInterest) * 100).toFixed(2) + '%'
    };
}

// --- HELPER FUNCTIONS ---

function calcProgressive(taxable, brackets) {
    let tax = 0;
    let previousLimit = 0;
    for (const b of brackets) {
        if (taxable > previousLimit) {
            const amountInBracket = Math.min(taxable, b.limit) - previousLimit;
            tax += amountInBracket * b.rate;
            previousLimit = b.limit;
        }
    }
    return tax;
}

function calcPrefTax(ordTaxable, prefIncome, status, idx) {
    // Simplified Fed Capital Gains Brackets (0%, 15%, 20%)
    const thresholds = (status === 'MFJ' ? [94050, 583750] : [47025, 518900]).map(v => v * idx);
    let tax = 0;
    let remainingPref = prefIncome;
    let currentLevel = ordTaxable;

    // 0% tier
    const zeroCap = Math.max(0, thresholds[0] - currentLevel);
    remainingPref -= Math.min(remainingPref, zeroCap);
    currentLevel += Math.min(prefIncome, zeroCap);

    // 15% tier
    if (remainingPref > 0) {
        const fifteenCap = Math.max(0, thresholds[1] - currentLevel);
        const amountAtFifteen = Math.min(remainingPref, fifteenCap);
        tax += amountAtFifteen * 0.15;
        remainingPref -= amountAtFifteen;
    }
    // 20% tier
    if (remainingPref > 0) tax += remainingPref * 0.20;
    return tax;
}


function getFedBrackets(status, idx) {
    return status === 'MFJ' 
        ? [{limit: 23850*idx, rate: 0.1}, {limit: 96950*idx, rate: 0.12}, {limit: 206700*idx, rate: 0.22}, {limit: 394600*idx, rate: 0.24}, {limit: 1e9, rate: 0.32}]
        : [{limit: 11925*idx, rate: 0.1}, {limit: 48475*idx, rate: 0.12}, {limit: 103350*idx, rate: 0.22}, {limit: 197300*idx, rate: 0.24}, {limit: 1e9, rate: 0.32}];
}

function getCABrackets(status, idx) {
    const base = [{limit: 10412, rate: 0.01}, {limit: 24684, rate: 0.02}, {limit: 38959, rate: 0.04}, {limit: 54081, rate: 0.06}, {limit: 68348, rate: 0.08}, {limit: 349137, rate: 0.093}, {limit: 418961, rate: 0.103}, {limit: 698271, rate: 0.113}, {limit: 1e9, rate: 0.123}];
    return base.map(b => ({ limit: b.limit * (status === 'MFJ' ? 2 : 1) * idx, rate: b.rate }));
}

// Do a progressive calculation on the bracket.
function calculateProgressive(entity, status, amount, inflation=1, ratecreep=1) {
 
    let brks = TAXData[entity]?.[status]?.brackets;
    
    if (!brks) {
        console.error(`Invalid tax data: entity="${entity}", status="${status}"`);
        return { cumulative: 0, total: 0, marginal: 0, limit: 0, error: 'Invalid entity or status' };
    }
    
    let prevLimit = 0;
    let cumulative = 0;
    let marginalRate = 0;
    
    for (let b of brks) {
        let currentLimit = b.l * inflation;
        
        if (amount <= currentLimit) {
            cumulative += (amount - prevLimit) * b.r * ratecreep;
            marginalRate = b.r * ratecreep;
            prevLimit = currentLimit;
            break;
        } else {
            cumulative += (currentLimit - prevLimit) * b.r * ratecreep;
            marginalRate = b.r * ratecreep;
            prevLimit = currentLimit;
        }
    }
    
    return { cumulative, total: cumulative, marginal: marginalRate, limit: prevLimit }
}

function calculateTax(fixed, ira, gains, status, a1, a2, inflation=1, ratecreep=1) {
    let std = TAXData["FEDERAL"]?.[status]?.std;
    if (a1 >= TAXData["FEDERAL"]?.[status]?.age) std += TAXData["FEDERAL"][status].stdbump * inflation;
    if (a2 >= TAXData["FEDERAL"]?.[status]?.age && status === 'MFJ') std += TAXData["FEDERAL"][status].stdbump * inflation;

    let agi = fixed + ira + gains;
    let taxable = Math.max(0, agi - std);
	
	let calc = calculateProgressive('FEDERAL', status, taxable, inflation);
	let fedTax = calc.cumulative;
	let fedRate = calc.marginal;
	let fedLimit = calc.limit;
	
	
	// Calculate (CA) State Tax
	// State basis is calculated differently.
	let stStd = TAXData["STATE"]?.[status]?.std;
	
	//!!!TODO: This is wrong. It should be calculated with the state deduction(s).
	let stAGI = taxable;
	calc = calculateProgressive('STATE', status, agi, inflation);
	let stTax = calc.cumulative;
	let stLimit = calc.limit;
	let stRate = calc.marginal;
	
	let totalTax = fedTax + stTax
	
    return { total: totalTax, fed: fedTax, state: stTax, magi: agi, stagi: stAGI, 
			fedLimit: fedLimit, stLimit: stLimit, fedRate: fedRate, stRate: stRate};
}

function calcIRMAA(magi, status, inflation) {
	let irmaalimit = findUpperLimitByAmount( 'IRMAA', status, magi, inflation)
	return irmaalimit.rate * inflation * 12
}

/** UI CONTROLS **/
function getInputs() {
    return {
		strategy: val('stratMode'), 	
        strat: val('stratMode'), nYears: +val('nYears'), stratRate: +val('stratRate')/100.0,
        birthyear1: +val('birthyear1'), die1: +val('die1'), birthyear2: +val('birthyear2'), die2: +val('die2'),
        ira1: +val('balIRA1'), ira2: +val('balIRA2'), roth: +val('balRoth'),
        brokerage: +val('balBrokerage'), basis: +val('basisBrokerage'), cash: +val('balCash'),
        ss1: +val('ss1'), ss1Age: +val('ss1Age'), ss2: +val('ss2'), ss2Age: +val('ss2Age'),
        pensionAnnual: +val('pensionAnnual'), survivorPct: +val('survivorPct'), spendGoal: +val('spendGoal'),
		spendChange: +val('spendChange')/100.0, 
		iraBaseGoal: +val('iraBaseGoal'),
        inflation: +val('inflation')/100.0, cpi: +val('cpi')/100.0, growth: +val('growth')/100.0, cashYield: +val('cashYield')/100.0,
		dividendRate: +val('dividendrate')/100.0,
		ssFailYear: +val('ssFailYear'), ssFailPct: +val('ssFailPct')/100.0,
		startInYear: +val('startInYear')
    };
}

function runSimulation() {
    let res = simulate(getInputs());
    updateTable(res.log);
    updateStats(res.totals, res.finalNW);
    updateCharts(res.log);
}

function runOptimizer() {
    let base = getInputs();
    let results = [];
    for (let n of [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 20, 25]) {
        base.strat = 'fixed';
        base.nYears = n;
        results.push({ 
		strategy: "Fixed", parameter: n, unit: "years", ...simulate(base) });
    }
    let html = results.map(r => `
        <tr>
            <td>${r.strategy} ${r.parameter} ${r.unit}</td>
            <td>$${Math.round(r.totals.tax).toLocaleString()}</td>
            <td>$${Math.round(r.finalNW).toLocaleString()}</td>
            <td>${(r.totals.tax/r.totals.gross*100).toFixed(1)}%</td>
			<td>${r.totals.yearsfunded}</td>
			<td>${r.totals.success ? 'ðŸŸ¢' : 'ðŸš¨'}</td>
			<td>${r.totals.yearstested}</td>
        </tr>
    `).join('');
    document.querySelector('#opt-table tbody').innerHTML = html;
    showTab('tab-opt');
}


function updateTable(log) {
	const oldTable = document.getElementById('main-table');

	if (!log || log.length === 0) {
		if (oldTable) {
		  oldTable.remove();
		}
		return null;
	}

	const table = document.createElement('table');
	table.border = '1';
	table.id = 'main-table';
  
	const keys = Object.keys(log[0]);

	// Create header
	const thead = table.createTHead();
	const headerRow = thead.insertRow();
	
	const tooltips = {
		'RMD-': 'Total of all RMDs (positive indicate withdrawals)',
		'BrokerageÎ”': 'Withdrawals are negative',
		'IRMAA': 'First two years are presumed the same as the 3rd year on.',
		'SpendGoal': 'With inflation, this amount increases.',
		'RothÎ”': 'Positive amounts are deposits, negative are withdrawals',
		'totalTax': 'Federal,IRMAA,NIIT,CapGains & IRMAA are all included.',
		'NominalTax%': 'TotalTax/TotalGrossIncome'
	};

	keys.forEach(key => {
		if (!key.startsWith('-')) {
			const th = document.createElement('th');
			th.textContent = key.endsWith('!') ? key.slice(0, -1) : key;
			
			if (tooltips[key]) {
				th.title = tooltips[key];
			}
			
			headerRow.appendChild(th);
		}
	});
  
	// Create body
	const tbody = table.createTBody();
	log.forEach(row => {
	  const tr = tbody.insertRow();
	  
	  // Check conditions for highlighting
	  const spendGoal = row['SpendGoal'] ?? row['spendGoal'];
	  const netIncome = row['NetIncome'] ?? row['netIncome'];
	  const totalWealth = row['TotalWealth'] ?? row['totalWealth'];
	  const age1 = row['Age1'] ?? row['age1'];
	  const age2 = row['Age2'] ?? row['age2'];
	  
	  const shouldHighlightPink = (spendGoal > netIncome) || (totalWealth < spendGoal);
	  const shouldHighlightYellow = (age1 === 'â€”' || age2 === 'â€”');
	  
	  // Pink takes priority over yellow
	  if (shouldHighlightPink) {
		tr.style.backgroundColor = '#ffb6c1';  // Light pink
	  } else if (shouldHighlightYellow) {
		tr.style.backgroundColor = '#ffff99';  // Light yellow
	  }
	  
	  keys.forEach(key => {
		if (!key.startsWith('-')) {
		  const td = tr.insertCell();
		  const value = row[key];
		  
		  // Check if key indicates percentage
		  const isPercent = key.toLowerCase().includes('%');
		  const isYear = key.toLowerCase().includes('yr') || key.toLowerCase().includes('year');
		  
		  if (value != null && !isNaN(value)) {
			if (isPercent) {
			  // Format as percentage (convert from decimal)
			  td.textContent = (value * 100).toFixed(2);
			} else {
			  // Format as whole number
			  if (isYear) {
				td.textContent = value;
			  } else {
				td.textContent = Math.round(value).toLocaleString();
			  }
			}
		  } else {
			td.textContent = value ?? '';
		  }
		  
		  tr.appendChild(td);
		}
	  });
	});
  
  if (oldTable) {
    oldTable.replaceWith(table);
  }
  
  return table;
}

/*calculateInflationAdjustedWithdrawal:
* given the parameters, determines the first year withdrawal (subsequent years are 
* adjusted for inflation).  At that rate, the asset would reach zero in *years*
*/
function calculateInflationAdjustedWithdrawal(principal, growthRate, inflationRate, years) {
    // Calculate real growth rate
    const realRate = growthRate - inflationRate;
	
	// Special case: principal is negative.
	if (principal <= 0) return 0;
    
    // Special case: when real growth is zero
    if (Math.abs(realRate) < 1e-10) {
        return principal / years;
    }
    
    // General case: first year withdrawal in today's dollars
    const denominator = 1 - Math.pow(1 + realRate, -years);
    const firstYearWithdrawal = principal * (realRate / denominator);
    
    return firstYearWithdrawal;
}


function updateStats(totals, finalNW) {
    document.getElementById('stat-rate').innerText = (totals.tax / totals.gross * 100).toFixed(1) + '%';
    document.getElementById('stat-spend').innerText = '$' + Math.round(totals.spend).toLocaleString();
    document.getElementById('stat-tax').innerText = '$' + Math.round(totals.tax).toLocaleString();
    document.getElementById('stat-nw').innerText = '$' + Math.round(finalNW).toLocaleString();
    document.getElementById('stat-years').innerText = totals.yearstested;
    document.getElementById('stat-yearsfunded').innerText = totals.yearsfunded;

}

let assetChart, taxChart;
function updateCharts(log) {
    const ctxA = document.getElementById('chartAssets').getContext('2d');
    if (assetChart) assetChart.destroy();
    assetChart = new Chart(ctxA, {
        type: 'line',
        data: {
            labels: log.map(r => r.year),
            datasets: [
                { label: 'IRAs', data: log.map(r => r.TotalIRA), borderColor: '#e67e22', fill: false },
                { label: 'Roth', data: log.map(r => r.RothBal), borderColor: '#000000', fill: false },
                { label: 'Brokerage', data: log.map(r => r.brokerageBal), borderColor: '#2980b9', fill: false },
                { label: 'Cash', data: log.map(r => r.CashBal), borderColor: '#27ae60', fill: false }
            ]
        },
        options: {
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return context.dataset.label + ': ' + 
                                   Math.round(context.parsed.y).toLocaleString();
                        }
                    }
                }
            }
        }
    });
    
    const ctxT = document.getElementById('chartTaxSpend').getContext('2d');
    if (taxChart) taxChart.destroy();
    taxChart = new Chart(ctxT, {
        type: 'line',
        data: {
            labels: log.map(r => r.year),
            datasets: [
                { label: 'Fed Tax', data: log.map(r => r.FedTax), borderColor: '#e74c3c', type: 'bar', backgroundColor: '#e74c3c', stacked: true},
                { label: 'State Tax', data: log.map(r => r.StateTax), borderColor: '#e74c3c', type: 'bar', backgroundColor: 'rgba(75, 192, 192, 0.7)', stacked: true},
                { label: 'IRMAA', data: log.map(r => r.IRMAA), borderColor: '#e74c3c', type: 'bar', backgroundColor: 'rgba(0, 0, 0, 1)', stacked: true },
                { label: 'Spendable Income', data: log.map(r => r.netIncome), borderColor: '#27ae60', fill: false, borderWidth: 3 }
            ]
        },
        options: {
            scales: {
                x: {
                    stacked: true
                },
                y: {
                    stacked: true,
                    ticks: {
                        callback: function(value) {
                            return Math.round(value).toLocaleString();
                        }
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return context.dataset.label + ': ' + 
                                   Math.round(context.parsed.y).toLocaleString();
                        }
                    }
                }
            }
        }
    });
}

function val(id) { return document.getElementById(id)?.value; }

function showTab(id) {
    // 1. Hide all tab content cards
    document.querySelectorAll('.tab-content, .card').forEach(c => { 
        if(c.id.startsWith('tab-')) c.classList.add('hidden'); 
    });
    // 2. Show the selected card
    document.getElementById(id).classList.remove('hidden');

    // 3. Update the active button styling (Fixed Selector)
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    const activeBtn = document.querySelector(`.tab-btn[onclick*="${id}"]`);
    if (activeBtn) activeBtn.classList.add('active');
}


function toggleStratUI() {
    let m = val('stratMode');
    document.getElementById('ui-fixed').classList.toggle('hidden', m !== 'fixed');
    document.getElementById('ui-bracket').classList.toggle('hidden', m !== 'bracket');
}



// Auto-run tests when page loads (comment out if you don't want auto-run)
// window.addEventListener('DOMContentLoaded', runTests);
runTests?.();
runSimulation?.();
</script>
</body>
</html>