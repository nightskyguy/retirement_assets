<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retirement Optimizer 7g</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<!-- <link rel="stylesheet" href="retirementopt_styles.css"> -->
	<link rel="stylesheet" href="retirementopt_styles_responsive.css">	
	<base target="_blank">	
	<script src="retirement_optimizer_tests.js"></script>	
	<script src="retirement_optimizer_text.js"></script>	
	<script src="retirement_optimizer_taxdata.js"></script>	
</head>
<body>

<div class="container">
	<div class="sidebar">
		<div id="strategy-container">
		    <div class="row"><div  id="spending">
				<div><label>After-Tax Spend &nbsp;
				<input type="number" id="spendGoal" value="150000"></label></div>
				<div><label title="Most retirees follow a spending smile where each year they spend less than the prior year. -2% means you spend 2% less each year. 0 means no change.">Spend Delta %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<input type="number" id="spendChange" value="-1" step="0.1" min="-25" max="25" placeholder="0.0"></label></div>
				</div><!-- spending -->
			</div>	<!-- class=row -->
		
		
			<div class="input-group">
				<select id="strategy" onchange="toggleStrategyUI()">
					<option value="baseline">ðŸ”„Withdraw Proportionally</option>  <!--âš–ï¸-->
					<option value="fixed">ðŸ’¸Reduce IRA in &#120393; Years</option>
					<option value="bracket">ðŸª£Fill Federal Tax Bracket</option>
					<option value="minlimit">ðŸ›‘Lesser of IRMAA or TaxBracket</option>
				</select>
			</div>
			
			<div id="ui-fixed" class="input-group hidden">
				<label>Target Years (&#120393;)
				<input type="number" id="nYears" value="10"></label>
			</div>
			
			<div id="ui-bracket" class="input-group hidden">
				<select id="stratRate">
					<option value="24" selected>24%(403/201)k</option>
				</select>
			</div>
		</div>  <!-- strategy-container -->
        <div class="row">	
		</div>
	
        <div class="row">
			<label title="Draw down IRA to this amount or less.">IRA Goal
            <input type="number" id="iraBaseGoal" value="750000" width="50%"></label><BR>
			<label title='If checked, it will use available cash to maximize Roth conversions'>
			  <input type="checkbox" id="maxConversion" name="maxConversion">
			  Max Conversion
			</label>
			
		</div>	
	
		
        <h3>1. Profile & Ages</h3>
        <div class="row">
            <div><label>Your Birth Year<input type="number" id="birthyear1" value="1960"></label></div>
            <div><label>Life Expectancy<input type="number" id="die1" value="88"></label></div>
        </div>
        <div class="row">
            <div><label>Spouse Birth Year</B><input type="number" id="birthyear2" value="1952"></label></div>
            <div><label>Spouse Expectancy<input type="number" id="die2" value="98"></label></div>
        </div>

        <h3>2. Assets (Current)</h3>
        <div class="row">
            <div><label>Your IRA  <input type="number" id="IRA1" value="1000000"></label></div>
            <div><label>Spouse IRA<input type="number" id="IRA2"  value="400000"></label></div>
        </div>
        <div class="row">
            <div><label>Brokerage<input type="number" id="Brokerage" value="100000"></label></div>
            <div><label>Brokerage Basis<input type="number" id="BrokerageBasis" value="100000"></label></div>
        </div>
        <div class="row">
            <div><label>Roth IRA<input type="number" id="Roth" value="50000"></label></div>
            <div><label>Cash Balance<input type="number" id="Cash" value="50000"></label></div>
        </div>

        <h3>3. Income (annual)</h3>
        <div class="row">
            <div><label>Social Security Amt<input type="number" id="ss1" value="48000"></label></div>
            <div><label>Start Age<input type="number" id="ss1Age" value="70"></label></div>
        </div>
        <div class="row">
            <div><label>Spouse SS Amt<input type="number" id="ss2" value="24000"></label></div>
            <div><label>Spouse Start Age<input type="number" id="ss2Age" value="70"></div></label><BR>
        </div>
        <div class="row">
            <div><label>Your Pension<input type="number" id="pensionAnnual" value="15000"></label></div>
            <div><label>Survivorship %<input type="number" id="survivorPct" value="75"></label></div>
        </div>


        <h3>4. Assumptions</h3>
        <div class="row">
            <div><label><A HREF="https://www.investopedia.com/inflation-rate-by-year-7253832" target="_blank">Inflation</A> (3?)%<input type="number" id="inflation" value="3.0" step="0.01" min="0" placeholder="0.00"></label></div>
            <div><label><A HREF="https://www.bls.gov/regions/mid-atlantic/data/consumerpriceindexhistorical_us_table.htm" target="_blank">CPI</A>/<A HREF="https://www.fool.com/retirement/social-security/cola-history/" target="_blank">COLA</A> (2.8?)%<input type="number" id="cpi" value="2.8" step="0.01" min="0" placeholder="0.00"></label></div>
        </div>
        <div class="row">
            <div><label title="Your asset mix will dictate what growth rate to expect. In a brokerage, your basis doesn't grow at the rate the account does. Note that the dividend rate is additive. 4% growth and 2% dividends = 6% total.">Growth (6)%<input type="number" id="growth" value="6.0"></label></div>
            <div><label title="What does your HYSA and/or Mutual fund produce annually?">Cash Interest (2.5)%?<input type="number" id="cashYield" value="3.0" step="0.01" min="0" placeholder="0.00"></label></div>
        </div>
        <div class="row">
			<div><label title="This is the rate that your asset mix emits dividends. Brokerage dividends accrue to the Cash account. Others to their own account.">Dividend Rate %<BR><input type="number" id="dividendRate" value="0.5" step="0.01" min="0" placeholder="0.00"></label></div>
			<div><label title="Pick the state that you live in or plan to live in through retirement"><STRONG>State</STRONG> Taxation<BR>
            <select id="STATEname"">
                <option   value="NONE">-No State Tax-</option>
                <option   value="CA" selected>California</option>
            </select></label>
			</div>			
		</div>
        <div class="row">
			<div><label title="Social security is on track to exhaust the trust fund in 2033. You can change what year this occurs in.">Social Security Fail <input type="number" id="ssFailYear" value="2033"></label></div>
            <div><label title="If you think social security will not fall to a 77.3% payout in 2033, set this number to 100">SS Net Payout%<input type="number" id="ssFailPct" value="77.3"></label></div>
        </div>

    </div> <!-- sidebar -->

    <div class="main">
        <div class="top-bar">
            <div id="summary-stats" style="display:flex; gap:30px;">
				<div id="stat-success">  </div>
				<div title="How many years of life are fully funded."><small>Funded/Years of Life</small><br><strong id="stat-years">0</strong></div>
                <div title="Total taxes paid/total spendable wealth"><small>LIFETIME TAX RATE</small><br><strong id="stat-rate">0%</strong></div>
                <div title="Sum of all taxes paid."><small>TOTAL TAX</small><br><strong id="stat-tax">$0</strong></div>
                <div title="How much spendable income was produced."><small>TOTAL Spendable</small><br><strong id="stat-spend">$0</strong></div>
                <div title="Remaining wealth at the end of life."><small>FINAL WEALTH</small><br><strong id="stat-nw">$0</strong></div>
				<div id="popUpMessage" class="scenario-message"></div>
            </div>
        </div>

        <div class="tabs">
            <button id="btn-tbl" class="tab-btn active" onclick="{runSimulation(); showTab('tab-tbl')}">Annual Details âŠž</button>
            <button id="btn-cht" class="tab-btn" onclick="{runSimulation(); showTab('tab-chart')}">Chart ðŸ“Š</button>
            <button id="btn-opt" class="tab-btn" onclick="{runOptimizer(); showTab('tab-opt')}">Optimizer ðŸŽ¯</button>
		    <button id="btn-fileio" class="tab-btn" onclick="{showTab('tab-fileio')}">Import/Export ðŸ“‚</button>
		    <button id="btn-docs" class="tab-btn" onclick="{showTab('tab-docs')}">Documentation <strong id="testsFailed">ðŸŸ¢</strong></button>

        </div>

		<div id="tab-fileio" class="card hidden">
			<div class="scenario-controls">
				<div class="scenario-row">
					<input type="text" id="scenarioName" placeholder="Scenario name (optional)" style="flex: 1; margin-right: 10px;">
					<button onclick="saveScenario()">Save</button>
					<button onclick="manageScenarios()">Load, Delete, Export</button>
					<button onclick="importScenario()">Import</button>
				</div>
				<div id="scenarioList" style="display: none; margin-top: 10px;">
					<!-- Scenario list will be populated here -->
				</div>
			</div>

			<!-- Modal for managing scenarios -->
			<div id="scenarioModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
				<div style="background: white; margin: 50px auto; padding: 20px; max-width: 600px; border-radius: 8px; max-height: 80vh; overflow-y: auto;">
					<h3>Saved Scenarios</h3>
					<div id="scenarioListContent"></div>
					<button onclick="closeScenarioModal()" style="margin-top: 10px;">Close</button>
				</div>
			</div>	
		</div>

		<div id="tab-docs" class="card hidden">
			<div class="header-drawers">
				<details class="top-drawer">
					<summary>How to Use</summary>
					<div class="drawer-content" id="drawer-howto"></div>
				</details>
			</div> <!-- header-drawers -->
			<div id="insights">
			ðŸ›‘ Some pithy insights will appear here. Right now they are not implemented. Insights shall   
			include observations like: which strategy seems most effective, what the net withdrawal rate will be for the given <i>After-Tax Spend</i> 
			<h4>Where is the Code</h4>
			This might be useful to know: you can run this locally (download the *.html and *.js and *.css files from github) 
			<A HREF="https://github.com/nightskyguy/retirement_assets">https://github.com/nightskyguy/retirement_assets</A>.
			<p>And you can also take a look at the source, make comments, or even open a pull request to propose changes. Just follow the link above.

			You can directly <strong>run</strong> the code from github: <A HREF="https://nightskyguy.github.io/retirement_assets/retirement_optimizer.html">nightskyguy.github.io/retirement_assets/retirement_optimizer.html</a>
			
			<H4>Other Tools</H4>		
			There is a standalone tool to determine what IRA balances (with RMDs) cause IRMAA taxation:  
			<A HREF="https://nightskyguy.github.io/retirement_assets/irmaa_and_rmds.html">nightskyguy.github.io/retirement_assets/irmaa_and_rmds.html</A>
			
			
			<p>If you're wondering whether you're being tracked, the answer is no. There is no logic 
			(currently) to do any kind of tracking or telemetry. You can read the code if you're skeptical.
			And by the way, you SHOULD be skeptical.  Sooner or later I am going to want to know 
			how many users are using it and from (approximately) where. Mostly for self edification, but also to know if, for example, lots of Idaho users are loading it... it would be clue to add state taxes for Idaho.
			</div>	

			<div id="tab-insight" class="card hidden">
				<table id="insights-table">
					<thead>
						<tr id="groupRow"></tr>
						<tr id="headerRow"></tr>
					</thead>
					<tbody id="tableBody"></tbody>
				</table>
			</div>
				<!--details class="top-drawer"><summary>Change Log</summary>			
				<div class="drawer-content" id="drawer-changelog"> 
				<!--- CHANGE LOG     CHANGE LOG     CHANGE LOG     CHANGE LOG     CHANGE LOG     CHANGE LOG     CHANGE LOG --->
				<H3>Change Log</H3>
				<ul>
				<li><b>7g</b> Found one source of overwithdrawal: the tax rate on capital gains should be proportional to the basis.
				
				<li>7f Fixed HTML cautions. Fixed error in calculating what to do with surplus. It was putting some surplus into Roth even though no IRA withdrawals had occurred. CapitalGains calculation was wrong, and the tax burden for Brokerage withdrawals was also incorrect. <B>BUG</B> However it's still significantly over-withdrawing.
				<li>7e Fixed more bugs, added much more information (See the <A HREF="https://nightskyguy.github.io/retirement_assets/">README.md</A>). And added a new standalone tool. 
				<li>7d Updated taxation calculations to use a more thorough calculator.
				<li>7c Prior update(s) broke the save/load functionality due to case changes.  Adjust IRMAA calculations to account for different growth rate of the tax from the CPI rate. IRMAA is tied to Medicare which annually increases by 5.6% over the last 20 years. The rate is encoded in the TAXdata table - not user adjustable. Began UI change to move the top tabs into a new location: Documentation.</li>
				<li>7b More state rates. Fixed most calculations. Minor UI changes. Changed the defaults to something "more common" - . See the <A HREF="https://nightskyguy.github.io/retirement_assets/">README.md</A>. </li>					
				<li>7a Now has various state rates. Fixed most calculations. See <A HREF="https://nightskyguy.github.io/retirement_assets/">README.md</A> for details. </li>	
				
				<li>6v Implemented Save/Load/Export/Delete Scenarios.</li>	
				<li>6u Implemented SS Fail. More UI fixes. Moved all strategy items to the top.</li>	
				<li>6t Solved a math issue causing NaN to occur. Cleaned up the visuals.</li>				
				<li>6s Some more fancy highlighting of the tables. Fixed broken strategy changer. Tests moved into separate file, too.</li>				
				<li>6r Moved the heavy text (top drawers) into a separate file.</li>
				<li>6q Beautifications and hover notes. More self tests with an indicator on screen if they fail. Started the Social Security "meltdown" implementation. Added (empty) Insights tab.</li>
				<li>6p Corrected instructions for Single filer usage. Fixed error in brokerage tracking. Added brokerage dividend rate. Dividends automatically accrue to Cash.</li>
				<li>6n Calculation fixes. WARNING: detailed calculations not done - but current calcs are accurate.</li>
				<li>6m More self tests, some rework.</li>
				<li>6k Reworked tax brackets for sanity ease of update. Added more instructions. </li>
				<li>6j Move style sheet out for readability.</li>
				<li>6i Remove the Recalculate and Optimize buttons. Use the similarly named tabs as the buttons. </li>
				<li>5hp Integrated Federal SS "Tax Torpedo" logic, California HSA add-backs, and IRMAA cliff surcharges. This logic is present, but not yet being used.  The older logic is "close".
				<li>5h Added change log and instructions</li>
				<li>4g Do rate limit lookups based on inflation. Add suggested values.</li>
				<li>4f Use cpi% to adjust taxation (brackets)</li>
				<li>4e Use calculated birthyear for correct RMDs</li>
				</ul>
				<!-- </div> <!-- changelog --
				</details>	-->
		</div> <!-- id=tab-docs -->

		<div id="tab-tbl" class="card table-wrap">
			<div class="column-controls">
				<label class="all-columns">
					<input type="checkbox" id="show-all" onchange="updateColumnVisibility()"> Show All
				</label>
				<label class="all-columns">
					<input type="checkbox" id="show-empty-columns" onchange="updateColumnVisibility()"> Show Zero
				</label>
				<label>
					<input type="checkbox" id="cat-summary" checked onchange="updateColumnVisibility()"> Summary
				</label>
				<label>
					<input type="checkbox" id="cat-balances" onchange="updateColumnVisibility()"> Balances
				</label>
				<label>
					<input type="checkbox" id="cat-taxation" onchange="updateColumnVisibility()"> Taxation
				</label>
				<label>
					<input type="checkbox" id="cat-ira" onchange="updateColumnVisibility()"> IRA Î”
				</label>
				<label>
					<input type="checkbox" id="cat-roth" onchange="updateColumnVisibility()"> Roth Î”
				</label>
				<label>
					<input type="checkbox" id="cat-brokerage" onchange="updateColumnVisibility()"> Brokerage Î”
				</label>
				<label>
					<input type="checkbox" id="cat-cash" onchange="updateColumnVisibility()"> Cash Î”
				</label>
			</div><!-- class="column-controls" -->
			<table id="main-table">
				<thead>
					<tr id="groupRow"></tr>
					<tr id="headerRow"></tr>
				</thead>
				<tbody id="tableBody"></tbody>
			</table>
		</div>

        <div id="tab-chart" class="card hidden">
            <canvas id="chartAssets" style="max-height:350px;"></canvas>
            <hr>
            <canvas id="chartTaxSpend" style="max-height:350px;"></canvas>
        </div>

        <div id="tab-opt" class="card hidden table-wrap">
            <table id="opt-table">
                <thead>

                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // document.getElementById('drawer-changelog').innerHTML = drawerContent.changelog;
    document.getElementById('drawer-howto').innerHTML = drawerContent.howToUse;
    // document.getElementById('drawer-planned').innerHTML = drawerContent.planned;
    // document.getElementById('drawer-background').innerHTML = drawerContent.background;
});

// CONFIGURATION CONSTANTS
// ============================================================================

// Version constant - increment this when data structure changes
const SCENARIO_VERSION = 4;

// New storage key for current version scenarios
const STORAGE_KEY = 'SLCRetireOptimizeScenario';

// Old storage key from previous version
const OLD_STORAGE_KEY = 'retirementScenarios';



/** TAX CONSTANTS **/
// Find these in retirement_optimizer_taxdata.js

// The default state to use for STATE calculations.
let STATEname = 'CA'

// For DEBUGGING. Sprinkled throughout to catch NaN and undefined values hiding in the data.
function inspectForErrors(namedObjects) {
	let errorsFound = false;
    for (const [objName, inputs] of Object.entries(namedObjects)) {
        for (const [name, value] of Object.entries(inputs)) {
            // Skip objects, arrays, functions, and booleans
            // if (typeof value === 'object' || typeof value === 'function' || 
            //     typeof value === 'boolean') {
            //     continue;
            // }
            
            if (value === undefined) {
                console.error(`âŒ ${objName}.${name} is undefined`);
            } else if (isNaN(value)) {
                // This catches both NaN numbers AND strings that evaluate to NaN
                console.error(`âŒ ${objName}.${name} is NaN (value: ${value}, type: ${typeof value})`);
				errorsFound = true;
            }
        }
    }
	if (errorsFound) debugger;
}

function getRMDPercentage(currentYear, birthYear) {
	const startAge = (birthYear >= 1960) ? 75 : 73;
	const age = currentYear - birthYear + 1;
    if (age < startAge) return 0;
    if (age > 120) return 1/RMD_TABLE[120];
    return 1/(RMD_TABLE[age]);
}

function getRateBracket(entity, status) {
    let brks = TAXData?.[entity]?.[status]?.brackets;

    if (!brks) {
        console.error(`Invalid tax data: entity="${entity}", status="${status}"`);
        return null
	};
		
	return brks
}

// Calculate the withdrawal rate to reduce an account from currentIRA to targetIRA
function calculateAmortizedWithdrawal(currentIRA, targetIRA, years, growthRate) {
    // Amount that needs to be withdrawn
    const excessAmount = currentIRA - targetIRA;
    
    // Grow the target to its future value
    const targetFV = targetIRA * Math.pow(1 + growthRate, years);
    
    // Calculate required annual withdrawal (amortization of excess)
    const r = growthRate;
    const n = years;
    
    if (r === 0) {
        return excessAmount / n;
    }
    
    const withdrawal = excessAmount * (r * Math.pow(1 + r, n)) / (Math.pow(1 + r, n) - 1);
    
    return withdrawal;
}


/**
 * Find the income limit for a specified marginal tax rate within tax brackets.
 * Returns the highest bracket limit where the rate is less than or equal to the target rate.
 * Uses TAXdata structure to retrieve bracket information.
 * 
 * @param {string} entity - Tax entity identifier (e.g., 'federal', 'CA', 'IRMAA', 'SS')
 * @param {string} status - Filing status (e.g., 'single', 'joint', 'mfs', 'hoh')
 * @param {number} tgtrate - Target marginal tax rate to find limit for
 * @param {number} [inflation=1] - Inflation multiplier for bracket limits (default: 1)
 * @returns {Object} Bracket limit results
 * @returns {number} return.limit - Income limit at or below the target rate (0 if no match)
 * @returns {number} return.rate - Actual rate of the bracket found
 * @note Does not validate input parameters for reasonableness
 */
function findLimitByRate( entity, status, tgtrate, inflation=1) {
    let brks = getRateBracket(entity, status)

    let limit = 0;
	let rate = 0;
	
    for (let b of brks) {
        if (b.r <= tgtrate ) {
			limit = b.l * inflation;
			rate = b.r;
        } else break;
    }
	return { limit, rate: rate }
}


// We want to find the limit of the next bracket HIGHER than the amount given (that is the upper limit).
// For example if the limits are 10, 100, 1000 and the amount is 150 - we want the 1000 (less 1).
// If amount is 99, we want 100.
function findUpperLimitByAmount( entity, status, amount, inflation=1) {
    let limit = 0;
	let rate = 0;
	let nominalRate = 0.0;
    let brks = getRateBracket(entity, status)
	
    for (let b of brks) {
        if (b.l * inflation <= amount ) {
			rate = b.r;
			nominalRate = b.nr ?? 0;
        } else {
			limit = b.l * inflation - 1;
			break;
		}
    }
	return { limit, rate: rate, nominalRate: nominalRate }
}

///

/**
 * Calculate taxable capital gains from a brokerage account withdrawal.
 * Determines the proportional basis reduction and resulting capital gains
 * based on the withdrawal amount relative to total account balance.
 * 
 * @param {number} withdrawal - Requested withdrawal amount
 * @param {number} brokerageBalance - Current total brokerage account balance
 * @param {number} brokerageBasis - Current cost basis in the brokerage account
 * @returns {Object} Withdrawal calculation results
 * @returns {number} return.withdrawn - Actual amount withdrawn (limited by balance)
 * @returns {number} return.capitalGains - Amount subject to capital gains tax
 * @returns {number} return.basisChange - Reduction in cost basis (always positive)
 * @note Withdrawal is capped at available balance
 * @note Uses proportional basis reduction method
 */
function calculateBrokerageWithdrawal(withdrawal, brokerageBalance, brokerageBasis) {
    // Can't withdraw more than available balance
    const actualWithdrawal = Math.min(withdrawal, brokerageBalance);
    
    // Calculate proportion of account being withdrawn
    const proportion = brokerageBalance > 0 ? actualWithdrawal / brokerageBalance : 0;
    
    // Calculate basis reduction (proportional to withdrawal)
    const basisChange = brokerageBasis * proportion;
    
    // Amount subject to capital gains = withdrawal minus the basis portion
    const capitalGains = actualWithdrawal - basisChange;
    
    return {
        withdrawn: actualWithdrawal,           // Total amount withdrawn
        capitalGains: capitalGains,            // Amount subject to capital gains tax
        basisChange: basisChange               // Change in basis (positive = reduction)
    };
}

/**
 * Calculates withdrawal amounts from multiple accounts based on strategy, accounting for taxes
 * @param {Object} balances - Balances
 * @param {number} balances.IRA - IRA balance
 * @param {number} balances.Brokerage - Brokerage account balance
 * @param {number} balances.BrokerageBasis - Brokerage cost basis
 * @param {number} balances.Cash - Cash balance
 * @param {number} balances.Roth - Roth IRA balance
 * @param {number} gapAmount - Total NET amount needed (after taxes)
 * @param {Object} withdrawStrategy - Withdrawal strategy definition
 * @param {Array<string>} withdrawStrategy.order - Order of ALL accounts (including zero-weight)
 * @param {Array<number>} withdrawStrategy.weight - Relative weights for each account in order if null, weights are based on Balances.
 * @param {Array<number>} withdrawStrategy.taxrate - Tax rates for each account (0.0 to 1.0)
 * @returns {Object} Withdrawal amounts (gross), taxes paid, net amounts, and remaining shortfall
 */
function calculateWithdrawals(balances, gapAmount, withdrawStrategy) {
    // Initialize result structure
    const result = {
        totalTax: 0,
        netAmount: 0,
        shortfall: 0
    };
    
    // Check edge cases
    let errors = [];
    
    gapAmount == null || (gapAmount <= 0) && errors.push("gapAmount is null or <= 0");
    (withdrawStrategy == null || Object.keys(withdrawStrategy).length === 0) && errors.push("withdrawStrategy is null or empty");
    (balances == null || Object.keys(balances).length === 0) && errors.push("balances is null or empty");
    (withdrawStrategy?.order == null || Object.keys(withdrawStrategy.order).length === 0) && errors.push("withdrawal.order is null or empty");
    
    if (errors.length > 0) {
        result.errors = errors;
        return result;
    }
    
    const order = withdrawStrategy.order;
    const taxrates = withdrawStrategy.taxrate;
    const originalGapAmount = gapAmount;
    
    const {BrokerageBasis, ...rest} = balances;
    let totalFunds = Object.values(rest).reduce((sum, v) => sum + v, 0);
    
    let normalizedWeight;
	
	// Normalize the weights (if they exist - or create weights from balances if not.
	if (withdrawStrategy.weight?.length > 0) {
	  const sum = withdrawStrategy.weight.reduce((a, b) => a + b, 0);
	  normalizedWeight = withdrawStrategy.weight.map(w => w / sum);
	} else {
	  const orderBalances = withdrawStrategy.order.map(acct => balances[acct]);
	  const sum = orderBalances.reduce((a, b) => a + b, 0);
	  normalizedWeight = orderBalances.map(bal => bal / sum);
	}	// withdrawStrategy.weight exists or not.	
	
    
    let netRemaining = gapAmount;
    
    // Phase 1: Process weighted accounts
    const netTargets = {};
    
    for (let i = 0; i < order.length; i++) {
        const account = order[i];
        const weight = normalizedWeight[i];
        netTargets[account] = weight > 0 ? (originalGapAmount * weight) : 0;
    }
    
    // Helper function to calculate effective tax rate for an account
    function getEffectiveTaxRate(account, grossWithdrawal) {
        if (account !== 'Brokerage') {
            // For non-brokerage accounts, use the full tax rate
            return taxrates[order.indexOf(account)] ?? 0;
        }
        
        // For brokerage, only tax the capital gains portion
        const brokerageInfo = calculateBrokerageWithdrawal(
            grossWithdrawal,
            balances.Brokerage,
            balances.BrokerageBasis
        );
        
        // Effective tax rate = (capital gains / total withdrawal) * tax rate
        const taxRate = taxrates[order.indexOf(account)] ?? 0;
        return grossWithdrawal > 0 ? (brokerageInfo.capitalGains / grossWithdrawal) * taxRate : 0;
    }
    
    // Helper function to perform a withdrawal from an account
    function performWithdrawal(account, grossWithdrawal, accountIndex) {
        if (grossWithdrawal <= 0.01) return { netWithdrawal: 0, tax: 0 };
        
        const taxRate = taxrates[accountIndex] ?? 0;
        let netWithdrawal, tax;
        
        if (account === 'Brokerage') {
            // Use the brokerage-specific calculation
            const brokerageInfo = calculateBrokerageWithdrawal(
                grossWithdrawal,
                balances.Brokerage,
                balances.BrokerageBasis
            );
            
            // Tax only applies to capital gains
            tax = brokerageInfo.capitalGains * taxRate;
            netWithdrawal = grossWithdrawal - tax;
            
            // Track basis change
            if (!result.BrokerageBasis) result.BrokerageBasis = 0;
            result.BrokerageBasis += brokerageInfo.basisChange; 
            
        } else {
            // For other accounts, simple calculation
            tax = grossWithdrawal * taxRate;
            netWithdrawal = grossWithdrawal - tax;
        }
        
        // Update result
        if (!result[account]) result[account] = 0;
        if (!result[account + 'Tax']) result[account + 'Tax'] = 0;
        
        result[account] += grossWithdrawal;
        result[account + 'Tax'] += tax;
        
        return { netWithdrawal, tax };
    }
    
    // Phase 1: Withdraw from weighted accounts up to their targets
    for (let i = 0; i < order.length; i++) {
        if (netRemaining <= 0.01) break;
        
        const account = order[i];
        const netTarget = netTargets[account];
        
        if (netTarget <= 0) continue; // Skip zero-weight accounts
        
        const available = balances[account] ?? 0;
        if (available <= 0.01) continue;
        
        // We need to solve for grossWithdrawal iteratively for brokerage
        // For simplicity, we'll use an approximation approach
        let grossWithdrawal;
        
        if (account === 'Brokerage') {
            // Iterative approach to find the right gross withdrawal
            // Start with an estimate
            const taxRate = taxrates[i] ?? 0;
            let estimate = netTarget / (1 - taxRate); // Initial estimate
            
            // Refine estimate (up to 3 iterations should be enough)
            for (let iter = 0; iter < 3; iter++) {
                const testInfo = calculateBrokerageWithdrawal(estimate, balances.Brokerage, balances.BrokerageBasis);
                const testTax = testInfo.capitalGains * taxRate;
                const testNet = estimate - testTax;
                
                if (Math.abs(testNet - netTarget) < 0.01) break;
                
                // Adjust estimate
                const correction = netTarget - testNet;
                estimate += correction / (1 - taxRate * (testInfo.capitalGains / estimate));
            }
            
            grossWithdrawal = Math.min(estimate, available, netTarget / (1 - taxRate) * 2); // Safety cap
        } else {
            const taxRate = taxrates[i] ?? 0;
            const grossTarget = netTarget / (1 - taxRate);
            const grossNeeded = netRemaining / (1 - taxRate);
            grossWithdrawal = Math.min(grossTarget, available, grossNeeded);
        }
        
        grossWithdrawal = Math.min(grossWithdrawal, available);
		inspectForErrors({available: available, grossWithdrawal: grossWithdrawal})
        
        const { netWithdrawal, tax } = performWithdrawal(account, grossWithdrawal, i);
        netRemaining -= netWithdrawal;
    }
    
    // Phase 2: If gap not satisfied, take from remaining balances in order
    if (netRemaining > 0.01) {
        for (let i = 0; i < order.length; i++) {
            if (netRemaining <= 0.01) break;
            
            const account = order[i];
            const alreadyWithdrawn = result[account] ?? 0;
            const available = (balances[account] ?? 0) - alreadyWithdrawn;
            
            if (available <= 0.01) continue;
            
            // Calculate how much gross we need to get the net we need
            let grossWithdrawal;
            
            if (account === 'Brokerage') {
                // Iterative approach for brokerage
                const taxRate = taxrates[i];
                let estimate = netRemaining / (1 - taxRate);
                
                for (let iter = 0; iter < 3; iter++) {
                    const remainingBalance = balances.Brokerage - alreadyWithdrawn;
                    const remainingBasis = balances.BrokerageBasis - (result.BrokerageBasis ?? 0);
                    
                    const testInfo = calculateBrokerageWithdrawal(estimate, remainingBalance, remainingBasis);
                    const testTax = testInfo.capitalGains * taxRate;
                    const testNet = estimate - testTax;
                    
                    if (Math.abs(testNet - netRemaining) < 0.01) break;
                    
                    const correction = netRemaining - testNet;
                    estimate += correction / (1 - taxRate * (testInfo.capitalGains / estimate));
                }
                
                grossWithdrawal = Math.min(estimate, available);
            } else {
                const taxRate = taxrates[i];
                const grossNeeded = netRemaining / (1 - taxRate);
                grossWithdrawal = Math.min(available, grossNeeded);
            }
            
            const { netWithdrawal, tax } = performWithdrawal(account, grossWithdrawal, i);
            netRemaining -= netWithdrawal;
        }
    }
    
    // Calculate totals
    let totalWithdrawals = Object.entries(result)
        .filter(([k]) => !k.endsWith('Tax') && !k.endsWith('Basis') && !k.includes('total') && k !== 'shortfall' && k !== 'netAmount' && k !== 'errors')
        .reduce((sum, [, v]) => sum + v, 0);
    
    result.totalTax = Object.entries(result)
        .filter(([k]) => k.endsWith('Tax'))
        .reduce((sum, [, v]) => sum + v, 0);
    
    result.netAmount = totalWithdrawals - result.totalTax;
    result.shortfall = Math.max(0, gapAmount - result.netAmount);
    
    // Round all results to 3 decimals
    Object.keys(result).forEach(k => {
        if (typeof result[k] === 'number') {
            result[k] = +result[k].toFixed(3);
        }
    });
    
    return result;
}


// Apply withdrawals  to the balances MUTATES balances!
function applyWithdrawals(balances, withdrawals) {
    for (const key in withdrawals) {
        if (key in balances) {
            balances[key] = Math.max(0, balances[key] - withdrawals[key]);
        }
    }
    return balances;  // Optional - for chaining/convenience
}

function accumulateWithdrawals(withdrawalsArray) {
    const totals = {};
    
    for (const withdrawals of withdrawalsArray) {
        for (const key in withdrawals) {
            if (key in totals) {
                totals[key] += withdrawals[key];
            } else {
                totals[key] = withdrawals[key];
            }
        } // for key in withdrawals
    } // for withdrawals
    return totals;
} // accumulateWithdrawals

// combines gains objects into one.
function combineGains(gains1, gains2) {
    const combined = {};
    const allKeys = new Set([...Object.keys(gains1), ...Object.keys(gains2)]);
    
    allKeys.forEach(key => {
        combined[key] = (gains1[key] ?? 0) + (gains2[key] ?? 0);
    });
    
    return combined;
}



/// Now allows specification of the number of months. Defaults to 12.
function applyGrowth(balances, growthRates, months = 12) {
    const gains = {}
    let gain = 0;
    const periodRate = months / 12;  // Fraction of year
    
    for (const key in balances) {
        if (key in growthRates) {
            // Apply proportional growth: balance * (rate * months/12)
            gain = balances[key] * growthRates[key] * periodRate;
            gains[key] = gain;
            balances[key] = Math.max(0, balances[key] + gain);
        }
        // If no matching rate, balance remains unchanged
    }
    return gains;  // Return the amounts gained/lost
}


function sumAccounts(obj, keys = ['IRA', 'IRA1', 'IRA2', 'Roth', 'Brokerage', 'Cash']) {
    return keys.reduce((sum, key) => sum + (obj[key] ?? 0), 0);
}

/////////////////////////////


let simulationCount = 0;
/** SIMULATION ENGINE **/
function simulate(inputs) {
    let balance = {
        IRA1: inputs.IRA1, IRA2: inputs.IRA2, Roth: inputs.Roth,
        Brokerage: inputs.Brokerage, BrokerageBasis: inputs.BrokerageBasis, Cash: inputs.Cash,
        magiHistory: []
    };
    simulationCount += 1;
	STATEname = inputs.STATEname;
    let log = [];
	//!!!TODO Remove hardcoded start year!
    let currentYear = inputs.startYear ?? 2026;
	let birthyear1 = inputs.birthyear1;
	let birthyear2 = inputs.birthyear2;

    let maxYears = Math.max(inputs.birthyear1 + inputs.die1, inputs.birthyear1 + inputs.die2) - currentYear + 1;
    let totals = { tax: 0, gross: 0, spend: 0, yearsfunded: 0, success: true, yearstested: 0, failedInYear: [] };

	let cpiRate = 1		// The rate that SS and Tax brackets increase.
	let inflation = 1	// The rate at which overall inflation increases.
	let medicareRate = 1	// The rate of increase in IRMAA tax and Medicare.
	let fixedWithdrawal = calculateAmortizedWithdrawal(balance.IRA1 + balance.IRA2, inputs.iraBaseGoal, inputs.nYears,inputs.growth)
	let currentTaxableGuess = 0;
	let spendDelta = 1
	let spendGoal = inputs.spendGoal;
	let cumulativeTaxes = 0;
	let nominalTaxRate = 0.20; // Just a guess.
	let marginalTaxRate = 0.33; // Just a guess.
	let capitalGainsRate = 0.15; // A guess.
	let tax = {};
	
	
	
	/**************************************
	 * PROCESS:
		Determine tax status 
		Determine SS & pension income.
	    Determine targetIncome based on strategy:
			For fixed, use larger of amortization rate or spendGoal
				WithdrawalStrategy = [IRA:100, Cash:0, Brok:0]
			For baseline, use SpendGoal 
				WithdrawalStrategy = [IRA, Brok, Cash, Roth] by balance percent.
			For delay, use SpendGoal
				WithdrawalStrategy = [Brok: 100, IRA: 0, Cash: 0
			For bracket, use larger of bracket limit or spendGoal
				WithdrawalStrategy = [IRA:*, Brok:*, Cash:0]
					
	 *
	 *************************************/

    for (let y = 0; y < maxYears; y++) {
		spendGoal = spendGoal * spendDelta * (1+inputs.inflation);
		
		cpiRate = (1 + inputs.cpi) * cpiRate;
		inflation = (1 + inputs.inflation) * inflation;
		spendDelta = 1 + inputs.spendChange;
		medicareRate *= ( 1 + TAXData.IRMAA.ANNUAL_INCREASE )
		
		let withdrawals = { IRA: 0, IRA1: 0, IRA2: 0, Roth: 0, Brokerage: 0, BrokerageBasis: 0, Cash: 0};
		let netWithdrawals = withdrawals;
		
        let age1 = currentYear - birthyear1 + 1;
        let age2 = currentYear - birthyear2 + 1;
        let alive1 = age1 <= inputs.die1;
        let alive2 = age2 <= inputs.die2;
        if (!alive1 && !alive2) break;

		totals.yearstested += 1;

        let status = (alive1 && alive2) ? 'MFJ' : 'SGL';
		// IRMAA is already known since it is based on income from 2 years ago.
        let irmaa = calcIRMAA(balance.magiHistory[balance.magiHistory.length-2], status, cpiRate, medicareRate);
		
		// Calculate the bracket limits based on: stated limit.
		let tgtBracketLimit = findLimitByRate('FEDERAL',status,inputs.stratRate)
		
		// Find federal & state rates and limits by spending goal:
		let goalFedBracketLimit = findUpperLimitByAmount('FEDERAL', status, spendGoal , cpiRate)
		let goalStateBracketLimit = findUpperLimitByAmount(STATEname, status, spendGoal, cpiRate)
		let goalLimit = Math.min(goalFedBracketLimit.limit, goalStateBracketLimit.limit)
		let irmaaBracket = findUpperLimitByAmount('IRMAA', status, goalLimit, cpiRate)
		let irmaLimit = Math.min(goalLimit, irmaaBracket.limit);
		let totalIncome =0;
		let netIncome = 0;
		let capitalGains = 0;		
	
		//!!! TODO: if strategy is "bracket" but spendGoal is > bracket limit
		//		    we likely have a problem unless non-taxable accounts can backfill.

        // 1. Inherit IRA
        if (!alive1 && balance.IRA1 > 0) { balance.IRA2 += balance.IRA1; balance.IRA1 = 0; }
        if (!alive2 && balance.IRA2 > 0) { balance.IRA1 += balance.IRA2; balance.IRA2 = 0; }


        // 2. Base Income
		let ssReduction = (inputs.ssFailYear > 2000 && currentYear >= inputs.ssFailYear) ? inputs.ssFailPct : 1;
        let s1 = (alive1 && age1 >= inputs.ss1Age) ? inputs.ss1 * cpiRate * ssReduction : 0;
        let s2 = (alive2 && age2 >= inputs.ss2Age) ? inputs.ss2 * cpiRate * ssReduction : 0;
        let pension = inputs.pensionAnnual;
		
		// One is deceased (if both decease, it won't get here)
        if (!alive1 || !alive2) {
            // Survivor Logic: Max of SS + Survivorship % of Pension
            s1 = Math.max(s1, s2);
            s2 = 0;
            if (!alive1) { pension = pension * (inputs.survivorPct/100) }
        }
        let fixedInc = s1 + s2;					// Social Security
		let taxableInc = pension;				// Pensions, W2, RMDs, IRA withdrawals, wdBrokerage
		
		// These will be APPROXIMATE worst case - no Withdrawals have been made.
		let taxableInterest = balance.Cash * inputs.cashYield
		let taxableDividends = balance.Brokerage * inputs.dividendRate
		

        // 3. RMDs
		let rmd1Pct = getRMDPercentage(currentYear, birthyear1);
		let rmd2Pct = getRMDPercentage(currentYear, birthyear2);
        let rmd1 = alive1 ? balance.IRA1 * rmd1Pct || 0 : 0;
        let rmd2 = alive2 ? balance.IRA2 * rmd2Pct || 0 : 0;
		rmd1Pct = Math.max(rmd1Pct, rmd2Pct, 0);
		rmd1Pct = Math.max(rmd1Pct, rmd2Pct, 0);
		
		// Immediately remove RMDs from the respective IRAs because they MUST be taken first.
		// TODO: Allow RMDs to go to QCDs one day!
		balance.IRA1 = Math.max(0, balance.IRA1 - rmd1);
		balance.IRA2 = Math.max(0, balance.IRA2 - rmd2);
		let curIRA = Math.max(0, balance.IRA1 + balance.IRA2 - inputs.iraBaseGoal);


		
        let totalRMD = rmd1 + rmd2;
		taxableInc += totalRMD

        // 4. Determine Target Spending amount based on Strategy
        let targetSpend = Math.min(spendGoal, goalLimit);
        let additionalSpendNeeded = Math.max(0, targetSpend - fixedInc - taxableInc + irmaa);

		//!!! Find the income federal limit. TODO: use that limit, to refine down to the next lower IRMAA limit and next lower State Limit.
		let marginalFedTaxRate = goalFedBracketLimit.rate
		let marginalStateTaxRate = goalStateBracketLimit.rate
		
		//	calculateProgressive('FEDERAL', status, amount, inflation=1, ratecreep=1)

		let nominalFedTaxRateAtLimit = 0.14;
		let nominalStateTaxAtLimit = 0.07
		let withdrawStrategy = {order: [], weight: [], taxrate: []};
		
		let curBalances = {IRA: balance.IRA1 + balance.IRA2, Brokerage: balance.Brokerage, BrokerageBasis: balance.BrokerageBasis, Roth: balance.Roth, Cash: balance.Cash, IRA1: balance.IRA1, IRA2: balance.IRA2};
		
		let capGainsPercentage = balance.Brokerage !== 0 
			? (balance.Brokerage - balance.BrokerageBasis) / balance.Brokerage 
			: 0;
			

        if (inputs.strategy === 'fixed') {
			// In this strategy, we confine withdrawals to the IRA for the first round. 
			// We don't care about the tax implications.
			
            let remYears = Math.max(1, inputs.nYears - y);
			let amortized = Math.max(0, fixedWithdrawal - totalRMD);

			// Withdraw the fixed amount left after RMDs, or whatever is left in IRAs after leaving room
			withdrawals = { IRA: Math.max(0,Math.min(curIRA, amortized)) }
			
        } else if (inputs.strategy === 'bracket' || inputs.strategy === 'minlimit') {
			//!!! This code has flaws.  Withdraws too much.
			let fedLimit = findLimitByRate('FEDERAL', status, inputs.stratRate, cpiRate);
			let limit = fedLimit.limit;
			let fedTaxAtLimit = calculateProgressive('FEDERAL', status, limit, inflation)
			nominalFedTaxRateAtLimit = fedTaxAtLimit.cumulative / limit
			marginalFedTaxRate = fedLimit.rate;	

			//!!!TODO Find the state rate and limit that corresponds to the limit (fedLimit.fedLimit)
			//!!!TODO Find the IRMAA limit that corresponds to the fedLimit.fedLimit
			let stLimit = findUpperLimitByAmount(STATEname, status, fedLimit.limit, cpiRate);
			marginalStateTaxRate = stLimit.rate;
			stateLimit = stLimit.limit;
			nominalStateTaxAtLimit = calculateProgressive(STATEname, status, limit, inflation).cumulative / limit
			
			// pick whatever is smaller (state or Federal limit for the amount desired)
			limit = Math.min(stateLimit, limit)
			
			if (inputs.strategy === 'minlimit') {
				limit = Math.min(limit, irmaLimit)
			}
			
            currentTaxableGuess = limit - fixedInc - taxableInc - totalRMD;
			
        } else {
			/*********************/
			/* BASELINE Strategy */
			/*********************/
	        // Withdraw enough proportionately to get to spendGoal - including taxes.
			withdrawStrategy.order = ['IRA', 'Brokerage', 'Cash']
			withdrawStrategy.taxrate = [ nominalTaxRate, capGainsPercentage * (capitalGainsRate + nominalStateTaxAtLimit), 0, 0]
			withdrawals = calculateWithdrawals(curBalances, additionalSpendNeeded, withdrawStrategy)
	
		}
		
		
		applyWithdrawals( curBalances, withdrawals)
		inspectForErrors( curBalances, withdrawals)
        
		netWithdrawals = accumulateWithdrawals( [netWithdrawals, withdrawals])
		capitalGains = Math.max(0, (netWithdrawals.Brokerage ?? 0) - (netWithdrawals.BrokerageBasis ?? 0));

        // 5. Tax Calc (Including IRMAA lag)
		//!!! TODO: May be premature. We may need more $ to meet spend goal.  We may have exhausted the IRAs.
		
		inspectForErrors({fixedInc: fixedInc, totalRMD: totalRMD, taxableInterest: taxableInterest, capitalGains: capitalGains, taxableDividends: taxableDividends, age1: age1, age2: age2, cpiRate: cpiRate})
			
			
		let tax = calculateTaxes({filingStatus: status, ages: [age1, age2], 
				ss1: s1, ss2: s2,
				earnedIncome: totalRMD + netWithdrawals.IRA + taxableInterest, inflation: cpiRate,
				qualifiedDiv: taxableDividends, capGains: capitalGains, hsaContrib: 0,
				taxExemptInterest: 0, state: STATEname })
		inspectForErrors(tax)  // See if any numbers look fishy.

		marginalFedTaxRate = tax.fedRate;
		marginalStateTaxRate= tax.stRate;

		//!!! Assume MAGI for prior to years is the same as this year. Should allow this to be entered
		
		let magiHistoryLength = balance.magiHistory.length
		if (magiHistoryLength < 1) {
			balance.magiHistory.push(tax.magi);
			balance.magiHistory.push(tax.magi);
		}

        let totalTax = tax.totalTax + irmaa;

        // 6. Cash Flow Gap
		let netSpendable = netWithdrawals.netAmount + fixedInc + taxableInc - totalTax
        let gap = targetSpend - netSpendable;
        
		inspectForErrors({netSpendable: netSpendable, gap: gap, totalTax: totalTax});

        if (gap > 1.00) {
			// We need to do more withdrawals.
			withdrawStrategy.order = ['Brokerage', 'Cash', 'IRA', 'Roth'];
			withdrawStrategy.weights = [40, 60, 0, 0];
			withdrawStrategy.taxrate = [capGainsPercentage * (capitalGainsRate + nominalStateTaxAtLimit), 0, nominalTaxRate, 0];
			withdrawals = calculateWithdrawals(curBalances, gap, withdrawStrategy);
			
			netWithdrawals = accumulateWithdrawals( [netWithdrawals, withdrawals])
			applyWithdrawals(curBalances, withdrawals);
        }
		
		// Recheck tax calculations due to possible additional withdrawals - and we now
		// have a more accurate income picture.
		capitalGains = Math.max(0, (netWithdrawals.Brokerage ?? 0) - (netWithdrawals.BrokerageBasis ?? 0));

		
		tax = calculateTaxes({filingStatus: status, ages: [age1, age2], 
				ss1: s1, ss2: s2,
				earnedIncome: totalRMD + netWithdrawals.IRA + taxableInterest, inflation: cpiRate,
				qualifiedDiv: taxableDividends, capGains: capitalGains, hsaContrib: 0,
				taxExemptInterest: 0, state: STATEname })
		inspectForErrors(tax)  // See if any numbers look fishy.

		// Now we have the "real tax"
		totalTax = tax.totalTax + irmaa;
		cumulativeTaxes += totalTax;

		
		totalIncome = Math.max(1, fixedInc + netWithdrawals.IRA + pension + taxableDividends +
						taxableInterest + netWithdrawals.Roth + netWithdrawals.Cash +
						netWithdrawals.Brokerage + totalRMD);
		
		inspectForErrors({totalIncome: totalIncome});
		
		nominalTaxRate = (tax.magi > 1.00) ? totalTax / tax.magi : 0.0;		

        // 7. Updates
		
		netIncome = totalIncome - totalTax;
		let surplus = {Total: Math.max(0, netIncome - spendGoal), Roth:0, Cash: 0, Brokerage: 0}
		
		//!!! Remove withdrawals proportionately. RMDs have already been withdrawn.
		const ira1_ratio = (balance.IRA1/(balance.IRA1+balance.IRA2||1))
        netWithdrawals.IRA1 = Math.max(0, netWithdrawals.IRA * ira1_ratio);
        netWithdrawals.IRA2 = Math.max(0, netWithdrawals.IRA * (1 - ira1_ratio));
		
		
		// If we took money from Roth, but have a surplus, replace the excess withdrawal - it was unnecessary
		surplus.Roth = Math.min(surplus.Total, netWithdrawals.Roth);
		netWithdrawals.Roth -= surplus.Roth;
		surplus.Total -= surplus.Roth;
		
		// We've "refunded" the Roth. If we still have a surplus, only the amount that came from IRAs can go to Roth
		surplus.Roth = Math.min( surplus.Total, netWithdrawals.IRA)
		surplus.Total -= surplus.Roth;

		// If there is still a surplus, replace any excess Cash withdrawal.
		surplus.Cash = Math.min( surplus.Total, netWithdrawals.Cash );
		netWithdrawals.Cash -= surplus.Cash;
		surplus.Total -= surplus.Cash;
			
		// Decrement the proposed withdrawals from the balance(s).
		applyWithdrawals(balance, netWithdrawals)

		let availableCash = balance.Cash + surplus.Total;
		let totalConverted = 0;

		if (inputs.maxConversion && availableCash > 1000) {
			// Determine order: largest IRA first
			let iras = [
				{ name: 'IRA1', withdrawal: netWithdrawals.IRA1 },
				{ name: 'IRA2', withdrawal: netWithdrawals.IRA2 }
			].sort((a, b) => b.withdrawal - a.withdrawal);
			
			let conversions = { IRA1: 0, IRA2: 0 };
			
			for (let ira of iras) {
				if (ira.withdrawal > 0 && availableCash > 0) {
					// Calculate max we can convert given available cash for taxes
					let maxConvertible = availableCash / nominalTaxRate;
					let actualConversion = Math.min(ira.withdrawal, maxConvertible);
					let taxOnConversion = actualConversion * nominalTaxRate;
					
					conversions[ira.name] = actualConversion;
					availableCash -= taxOnConversion;
					totalConverted += actualConversion;
				} // if ira.withdrawal > 0 && availableCash > 0
			} // for let ira of iras
			
			// Apply the conversions
			let totalTaxPaid = totalConverted * nominalTaxRate;
			
			// Apportion tax payment between Cash and surplus
			let taxFromCash = Math.min(balance.Cash, totalTaxPaid);
			let taxFromSurplus = totalTaxPaid - taxFromCash;
			
			balance.Cash -= taxFromCash;
			surplus.Total -= taxFromSurplus;
			withdrawals.Cash += totalTaxPaid;
		} // if maxConversion && availableCash > 1000
		
		// If there is STILL a surplus, put it in Cash.
		surplus.Cash = surplus.Total;
		balance.Cash += surplus.Cash
		surplus.Total = 0;
	
		//!!!TODO: Need to tax the growth of Cash and Brokerage!
		let growthRates = {IRA: inputs.growth, IRA1: inputs.growth, IRA2: inputs.growth, 
						   Brokerage: inputs.growth, Cash: inputs.cashYield, Roth: inputs.growth}
		
		// Grow Balances
		// TODO: Allow applying growth before and after withdrawals. 
		//       To simulate how things differ if withdrawals are done early or later in the year.
		
		let gains = applyGrowth( balance, growthRates)
		inspectForErrors(growthRates, balance, gains )  // See if any numbers look fishy.

 		// Accrue dividends to cash
		gains.Cash += taxableDividends
        balance.Cash +=  taxableDividends;
        balance.magiHistory.push(tax.magi);
        totals.tax += totalTax;
        totals.gross += (totalIncome);
        totals.spend += (targetSpend - Math.max(0, gap));
		balance.Roth += surplus.Total + totalConverted;
		
		let totalWealth = (balance.IRA1 + balance.IRA2 + Math.max(0, balance.Brokerage -   balance.BrokerageBasis)) * (1-nominalTaxRate) + balance.Roth + balance.Cash + balance.BrokerageBasis

		if (netIncome < targetSpend || totalWealth < (targetSpend * 2)) {
			totals.success = false;
			totals.failedInYear.push(currentYear)
		} else {
			totals.yearsfunded += 1
		}
		
		inspectForErrors({totalWealth: totalWealth} )  // See if any numbers look fishy.

        log.push({
            year: currentYear,
            age1: alive1 ? age1 : 'â€”',
            age2: alive2 ? age2 : 'â€”',
			status: status,
            SSincome: fixedInc,
			pension: pension,
            spendGoal: targetSpend,
			magi: tax.magi,
			totalIncome: totalIncome,
            netIncome: netIncome,	
            surplus: surplus.Total,	
			'RMD%': rmd1Pct,
			'RMD1-': rmd1,
			'RMD2-': rmd2,
            '-RMDwd': totalRMD,
			'IRA1-': netWithdrawals.IRA1,
			'IRA2-': netWithdrawals.IRA2,
            // 'IRAwd': netWithdrawals.IRA,
            'Brokerage-': netWithdrawals.Brokerage,
			'CapGains': capitalGains,
            'RothWD': netWithdrawals.Roth,
            'CashWD': netWithdrawals.Cash,
			'cashD+I': taxableDividends + taxableInterest,
			IRMAA: irmaa,
			FedTax: tax.federalTax,
			StateTax: tax.state,
            totalTax: totalTax,
            'fedLimit': tax.fedLimit,
			'stateLimit': tax.stLimit,
			'FedRate%': tax.fedRate,
			'StateRate%': tax.stRate,
			'NominalRate%': nominalTaxRate,
			'SumTaxes': cumulativeTaxes,
            IRA1: balance.IRA1,
			IRA2: balance.IRA2,
			TotalIRA: balance.IRA1 + balance.IRA2,
			Cash: balance.Cash,
			Roth: balance.Roth,
            Brokerage: balance.Brokerage,
            Basis: balance.BrokerageBasis,
            totalWealth: totalWealth,
			Spendable: totals.spend,
			cashG: gains.Cash,
			brokerageG: gains.Brokerage,
			rothG: gains.Roth,
			rothConv: totalConverted,
			rothBonusConv: surplus.Roth
        });
		currentYear += 1;
    } // end for (let y = 0; y < maxYears; y++)

    return { log, totals, finalNW: log[log.length-1].totalWealth };
}

/**
 * Calculate progressive tax on a given amount using tax brackets from TAXdata structure.
 * Iterates through brackets, applying rates to income ranges, with optional inflation
 * and rate creep adjustments for future year projections.
 * 
 * @param {string} entity - Tax entity identifier (e.g., 'federal', 'CA', 'IRMAA', 'SS')
 * @param {string} status - Filing status (e.g., 'single', 'joint', 'mfs', 'hoh')
 * @param {number} amount - Taxable amount to calculate tax on
 * @param {number} [inflation=1] - Inflation multiplier for bracket limits (default: 1)
 * @param {number} [ratecreep=1] - Rate adjustment multiplier (default: 1)
 * @returns {Object} Tax calculation results
 * @returns {number} return.cumulative - Total tax owed
 * @returns {number} return.total - Total tax owed (same as cumulative)
 * @returns {number} return.marginal - Marginal tax rate at this income level
 * @returns {number} return.limit - Upper limit of the bracket reached
 * @returns {number} return.nominalRate - Nominal rate if specified in bracket data
 * @returns {string} [return.error] - Error message if entity/status invalid
 */
function calculateProgressive(entity, status, amount, inflation=1, ratecreep=1) {
 
    let brks = getRateBracket(entity, status)
    if (!brks) {
        return { cumulative: 0, total: 0, marginal: 0, limit: 0, error: `Invalid entity (${entity}) or status (${status})` };
    }
    
    let prevLimit = 0;
    let cumulative = 0;
    let marginalRate = 0;
	let nominalRate = 0;
    
    for (let b of brks) {
        let currentLimit = b.l * inflation;
        
        if (amount <= currentLimit) {
            cumulative += (amount - prevLimit) * b.r * ratecreep;
            marginalRate = b.r * ratecreep;
			nominalRate = b.nr ?? 0;
            prevLimit = currentLimit;
            break;
        } else {
            cumulative += (currentLimit - prevLimit) * b.r * ratecreep;
            marginalRate = b.r * ratecreep;
			nominalRate = b.nr ?? 0;
            prevLimit = currentLimit;
        }
    }
    
    return { cumulative, total: cumulative, marginal: marginalRate, limit: prevLimit, nominalRate: nominalRate }
}


///////////////////////////
/**
 * Calculates Federal, State, Capital Gains (and NIIT) taxes. Include correct handling of Social Security Taxability. 
 * Inputs are as described below.
 * Outputs should include: 
 *   totalTax, federalTax, stateTax, capitalGainsTax, niitTax, AGI, and 
 *   the MAGI suitable for determining the IRMAA taxes in subsequent years.
 * 
 * @param {Object} params - Input parameters
 * @param {string} params.filingStatus - 'MFJ' (Married Filing Jointly) or 'SGL' (Single).
 * @param {Array}  params.ages - Array of ages [age1, age2] or [age1] if single.
 * @param {number} params.earnedIncome - Total of W2, IRA/401k withdrawals, pensions and RMDs.
 * @param {number} params.ss1 - Social Security for Person 1.
 * @param {number} params.ss2 - Social Security for Person 2 (0 if Single).
 * @param {number} params.ordDivInterest - Interest and Ordinary Dividends.
 * @param {number} params.qualifiedDiv - Qualified Dividends (taxed at lower rates Federally).
 * @param {number} params.capGains - Net Long Term Capital Gains.
 * @param {number} params.taxExemptInterest - Muni bond interest (non-taxable but used for SS/IRMAA/CA).
 * @param {number} params.hsaContrib - Total HSA contributions (deductible Fed, taxable CA).
 * @param {number} params.inflation - Inflation (CPI) multiplier for tax brackets (e.g., 1.025 for 2.5% cumulative).
 * @param {string} params.state - State abbreviation (e.g., 'CA', 'NONE').
 * @returns {Object} Comprehensive tax calculation results
 */
function calculateTaxes(params = {}) {
	// Destructure all parameters.
    const {
        filingStatus = 'MFJ',
        ages = [],
        earnedIncome = 0,
        ss1 = 0,
        ss2 = 0,
        ordDivInterest = 0,
        qualifiedDiv = 0,
        capGains = 0,
        taxExemptInterest = 0,
        hsaContrib = 0,
        inflation = 1.0,
        state = 'CA'
    } = params;
    
    // Normalize filing status to match TAXData keys
    const status = filingStatus ?? "MFJ";
    const totalSS = ss1 + ss2;
    
    // ========================================================================
    // STEP 1: Calculate Federal Standard Deduction (including age adjustments)
    // ========================================================================
    const federalStdBase = TAXData.FEDERAL[status].std;
    const federalAgeThreshold = TAXData.FEDERAL[status].age;
    const federalAgeBump = TAXData.FEDERAL[status].stdbump;
    
    let federalStdDeduction = federalStdBase * inflation;
    
    // Add age-based additional standard deduction
    if (ages[0] >= federalAgeThreshold) {
        federalStdDeduction += federalAgeBump * inflation;
    } // ages[0] check
    
    if (status === 'MFJ' && ages.length > 1 && ages[1] >= federalAgeThreshold) {
        federalStdDeduction += federalAgeBump * inflation;
    } // ages[1] check for MFJ
    
	// ========================================================================
	// STEP 2: Calculate Social Security Taxability (Federal)
	// ========================================================================
	// Get SS taxability brackets using helper function
	const ssBrackets = getRateBracket('SOCIALSECURITY', status);
	if (!ssBrackets) {
		return { error: `Unable to retrieve Social Security brackets for status: ${status}` };
	} // SS brackets validation

	// Provisional Income = AGI (before SS) + Tax-Exempt Interest + [rate%] of SS
	// The rate for provisional income is the second bracket rate (index 1)
	const provisionalIncomeRate = ssBrackets[1].r ?? 0;
	const provisionalIncome = (earnedIncome - hsaContrib + ordDivInterest + 
							  qualifiedDiv + capGains + taxExemptInterest + 
							  provisionalIncomeRate * totalSS);

	let taxableSS = 0;

	// Determine taxable portion based on provisional income
	if (provisionalIncome <= ssBrackets[0].l * inflation) {
		// Below first threshold - no SS is taxable
		taxableSS = 0;
	} else if (provisionalIncome <= ssBrackets[2].l * inflation) {
		// Between first and second threshold - taxable at tier 1 rate
		const threshold1 = ssBrackets[1].l * inflation;
		const tier1Rate = ssBrackets[1].r;
		const excessOver1 = provisionalIncome - threshold1;
		taxableSS = Math.min(tier1Rate * totalSS, tier1Rate * excessOver1);
	} else {
		// Above second threshold - taxable at tier 2 rate (with tier 1 portion)
		const threshold1 = ssBrackets[1].l * inflation;
		const threshold2 = ssBrackets[2].l * inflation;
		const tier1Rate = ssBrackets[1].r;
		const tier2Rate = ssBrackets[2].r;
		const excessOver2 = provisionalIncome - threshold2;
		
		// Calculate tier 1 amount (difference between thresholds at tier 1 rate)
		const tier1Amount = tier1Rate * (threshold2 - threshold1);
		
		// Calculate tier 2 amount (excess over threshold 2 at tier 2 rate)
		const tier2Amount = tier2Rate * excessOver2;
		
		// Total taxable SS is limited to tier 2 rate * total SS
		taxableSS = Math.min(tier2Rate * totalSS, tier1Amount + tier2Amount);
	} // SS taxability calculation
    
    // ========================================================================
    // STEP 3: Calculate Federal AGI and Taxable Income
    // ========================================================================
    const federalAGI = (earnedIncome - hsaContrib) + taxableSS + ordDivInterest + 
                       qualifiedDiv + capGains;
    
    const federalTaxableIncome = Math.max(0, federalAGI - federalStdDeduction);
    
    // ========================================================================
    // STEP 4: Separate Ordinary and Preferentially-Taxed Income
    // ========================================================================
    // Ordinary income components (taxed at regular rates)
    const ordinaryIncomeInAGI = (earnedIncome - hsaContrib) + taxableSS + ordDivInterest;
    
    // Preferentially-taxed income (qualified dividends + long-term cap gains)
    const preferentialIncomeInAGI = qualifiedDiv + capGains;
    
    // Determine how much of taxable income is ordinary vs. preferential
    // Standard deduction comes off ordinary income first
    const taxableOrdinaryIncome = Math.max(0, Math.min(federalTaxableIncome, 
                                            ordinaryIncomeInAGI - federalStdDeduction));
    const taxablePreferentialIncome = Math.max(0, federalTaxableIncome - taxableOrdinaryIncome);
    
    // ========================================================================
    // STEP 5: Calculate Federal Ordinary Income Tax
    // ========================================================================
    const federalOrdinaryResult = calculateProgressive('FEDERAL', status, 
                                                       taxableOrdinaryIncome, inflation);
    const federalOrdinaryTax = federalOrdinaryResult.total;
    const federalMarginalRate = federalOrdinaryResult.marginal;
    
    // ========================================================================
    // STEP 6: Calculate Federal Capital Gains Tax (including NIIT)
    // ========================================================================
    // Capital gains brackets are based on total taxable income position
    // We start applying cap gains rates where ordinary income ended
    const capGainsBrackets = TAXData.FEDERAL.CAPITAL_GAINS[status].brackets;
    let federalCapGainsTax = 0;
    let remainingPreferential = taxablePreferentialIncome;
    let currentPosition = taxableOrdinaryIncome; // Start where ordinary income left off
    
    // Apply capital gains rates based on position in total taxable income
    for (let i = 0; i < capGainsBrackets.length; i++) {
        const bracket = capGainsBrackets[i];
        const bracketLimit = bracket.l * inflation;
        const rate = bracket.r;
        
        // Skip brackets we've already passed
        if (currentPosition >= bracketLimit) {
            continue;
        } // bracket already passed
        
        // Calculate how much preferential income fits in this bracket
        const roomInBracket = bracketLimit - currentPosition;
        const amountInBracket = Math.min(remainingPreferential, roomInBracket);
        
        // Apply the rate to this portion
        federalCapGainsTax += amountInBracket * rate;
        remainingPreferential -= amountInBracket;
        currentPosition += amountInBracket;
        
        // Exit if we've taxed all preferential income
        if (remainingPreferential <= 0) {
            break;
        } // all preferential income taxed
    } // capital gains bracket loop
    
    // Total federal tax
    const federalTax = federalOrdinaryTax + federalCapGainsTax;
    
    // ========================================================================
    // STEP 7: Calculate State AGI and Taxable Income
    // ========================================================================
    // State differences from Federal AGI:
    // - California: HSA contributions are NOT deductible (add back)
    // - California: Social Security is NOT taxable (use different SS amount)
    // - California: No preferential rates for cap gains (all ordinary income)
    
    const stateData = TAXData[state];
    const stateSSTaxRate = stateData.SSTaxation || 0;
    
    // Calculate state-specific taxable SS
    const stateTaxableSS = totalSS * stateSSTaxRate;
    
    // State AGI calculation (CA adds back HSA)
    let stateAGI;
    if (state === 'CA') {
        // California: HSA not deductible, use state SS taxation rate
        stateAGI = earnedIncome + stateTaxableSS + ordDivInterest + 
                   qualifiedDiv + capGains;
    } else {
        // Other states: may follow federal treatment more closely
        stateAGI = earnedIncome - hsaContrib + stateTaxableSS + ordDivInterest + 
                   qualifiedDiv + capGains;
    } // state AGI calculation
    
    // State standard deduction
    const stateStdDeduction = stateData[status].std * inflation;
    
    // State taxable income
    const stateTaxableIncome = Math.max(0, stateAGI - stateStdDeduction);
    
    // ========================================================================
    // STEP 8: Calculate State Tax
    // ========================================================================
    const stateResult = calculateProgressive(state, status, stateTaxableIncome, inflation);
    const stateTax = stateResult.total;
    const stateMarginalRate = stateResult.marginal;
    
    // ========================================================================
    // STEP 9: Calculate IRMAA MAGI (for future year IRMAA determination)
    // ========================================================================
    // IRMAA MAGI = Federal AGI + Tax-Exempt Interest
    const irmaaMagi = federalAGI + taxExemptInterest;
    
    // ========================================================================
    // STEP 10: Calculate Total Tax and Return Results
    // ========================================================================
    const totalTax = federalTax + stateTax;
    
    return {
        // Primary outputs requested		
        totalTax: totalTax,
        federalTax: federalTax,
        stateTax: stateTax,
		state: stateTax,
        capitalGainsTax: federalCapGainsTax,  // Includes NIIT
        niitTax: 0,  // Included in capitalGainsTax (combined brackets)
        AGI: federalAGI,
        irmaaMagi: irmaaMagi,
        magi: irmaaMagi,
        
        // Additional detailed breakdown
        federalOrdinaryTax: federalOrdinaryTax,
        federalMarginalRate: federalMarginalRate,
		fedRate: federalMarginalRate,
		
        stateMarginalRate: stateMarginalRate,
		stRate: stateMarginalRate,
		
		fedLimit: federalOrdinaryResult.limit,
		stLimit: stateResult.limit,
        
        // Income components
        taxableSS: taxableSS,
        provisionalIncome: provisionalIncome,
        federalTaxableIncome: federalTaxableIncome,
        stateTaxableIncome: stateTaxableIncome,
        stateAGI: stateAGI,
        stagi: stateAGI,
        
        // Standard deductions applied
        federalStdDeduction: federalStdDeduction,
        stateStdDeduction: stateStdDeduction,
        
        // Income breakdown for verification
        ordinaryIncomeInAGI: ordinaryIncomeInAGI,
        preferentialIncomeInAGI: preferentialIncomeInAGI,
        taxableOrdinaryIncome: taxableOrdinaryIncome,
        taxablePreferentialIncome: taxablePreferentialIncome
    }; // return object
} // calculateTaxes()



///////////////////////////

function calcIRMAA(magi, status, cpiRate, medicareRate = (1 + TAXData.IRMAA.ANNUAL_INCREASE)) {
	
	let irmaalimit = findUpperLimitByAmount( 'IRMAA', status, magi, cpiRate)
	return irmaalimit.rate * medicareRate * 12
}

/** UI CONTROLS **/
function getInputs() {
	// TODO: If we override these values, we should update the UI 
	let spendChange = +val('spendChange')
	if (spendChange < -25 || spendChange > 25) {
		showMessage('Spend Delta: '+ spendChange +'% is unreasonable. Using 0% instead.', 'warning')
		spendChange = 0
		}
	let Brokerage = +val('Brokerage');
	let BrokerageBasis = +val('BrokerageBasis');
	if (Brokerage <= 0.01) basis = 0;
	if (BrokerageBasis > Brokerage) {
		showMessage('BrokerageBasis (' + BrokerageBasis + ') was greater than the Brokerage balance. BrokerageBasis in input is being ignored. Using ' + Brokerage + ' instead.', 'warning');
		BrokerageBasis = Brokerage;
		}
    return {
		STATEname: val('STATEname'), 	
		strategy: val('strategy'), 	
		nYears: +val('nYears'), 
		stratRate: +val('stratRate')/100.0,
        birthyear1: +val('birthyear1'), 
		die1: +val('die1'), 
		birthyear2: +val('birthyear2'), 
		die2: +val('die2'),
        IRA1: +val('IRA1'), 
		IRA2: +val('IRA2'), 
		Roth: +val('Roth'),
        Brokerage: Brokerage, 
		BrokerageBasis: BrokerageBasis, 
		Cash: +val('Cash'),
        ss1: +val('ss1'), 
		ss1Age: +val('ss1Age'), 
		ss2: +val('ss2'), 
		ss2Age: +val('ss2Age'),
        pensionAnnual: +val('pensionAnnual'), 
		survivorPct: +val('survivorPct'), 
		spendGoal: +val('spendGoal'),
		spendChange: (spendChange/100.0), 
		iraBaseGoal: +val('iraBaseGoal'),
        inflation: +val('inflation')/100.0, 
		cpi: +val('cpi')/100.0, 
		growth: +val('growth')/100.0, 
		cashYield: +val('cashYield')/100.0,
		dividendRate: +val('dividendRate')/100.0,
		ssFailYear: +val('ssFailYear'), 
		ssFailPct: +val('ssFailPct')/100.0,
		maxConversion: valChecked('maxConversion'),
		startInYear: +val('startInYear')
    };
}

/*
 *
 *
 */
function runSimulation() {
    let res = simulate(getInputs());
    updateTable(res.log);
    updateStats(res.totals, res.finalNW);
    updateCharts(res.log);
}
// //////////////////////////////////////////////////////////////////

function runOptimizer() {
    let base = getInputs();
    let results = [];
    
    for (let n of [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 20, 25]) {
        base.strategy = 'fixed';
        base.nYears = n;
        results.push({ 
            strategy: "Fixed", 
            parameter: n, 
            unit: "years", 
            ...simulate(base) 
        });
    }
    
    // Find best result
    const successfulResults = results.filter(r => r.totals.success);
    
    let bestIndex = -1;
    if (successfulResults.length > 0) {
        const minTax = Math.min(...successfulResults.map(r => r.totals.tax));
        const lowestTaxResults = successfulResults.filter(r => r.totals.tax === minTax);
        
        if (lowestTaxResults.length === 1) {
            bestIndex = results.indexOf(lowestTaxResults[0]);
        } else {
            const maxWealth = Math.max(...lowestTaxResults.map(r => r.finalNW));
            const bestResult = lowestTaxResults.find(r => r.finalNW === maxWealth);
            bestIndex = results.indexOf(bestResult);
        }
    }
    
    // Define columns
    const columns = [
        { 
            label: "Success/Fail", 
            getValue: r => r.totals.success ? 'ðŸŸ¢' : 'ðŸš¨' 
        },
        { 
            label: "Strategy", 
            getValue: r => `${r.strategy} ${r.parameter} ${r.unit}` 
        },
        { 
            label: "Lifetime Tax", 
            getValue: r => `${Math.round(r.totals.tax).toLocaleString()}` 
        },
        { 
            label: "Final Wealth", 
            getValue: r => `${Math.round(r.finalNW).toLocaleString()}` 
        },
        { 
            label: "Effective Tax Rate", 
            getValue: r => `${(r.totals.tax/r.totals.gross*100).toFixed(1)}%` 
        },
        { 
            label: "Years Funded/Total", 
            getValue: r => r.totals.yearsfunded + '/' + r.totals.yearstested
        }
    ];
    
    // Build header row
    const headerHtml = '<tr>' + columns.map(col => `<th>${col.label}</th>`).join('') + '</tr>';
    
    // Build data rows
    const rowsHtml = results.map((r, idx) => {
        const isBest = idx === bestIndex;
        const rowStyle = isBest ? ' style="background-color: #90EE90; font-weight: bold; cursor: pointer;"' : ' style="cursor: pointer;"';
        
        const cells = columns.map(col => `<td>${col.getValue(r)}</td>`).join('');
        
        return `<tr${rowStyle} onclick="loadOptimizerResult(${idx})" title="Click to load this strategy">${cells}</tr>`;
    }).join('');
    
    // Store results globally so loadOptimizerResult can access them
    window.optimizerResults = results;
    
    // Update table
    document.querySelector('#opt-table thead').innerHTML = headerHtml;
    document.querySelector('#opt-table tbody').innerHTML = rowsHtml;
    showTab('tab-opt');
}

// Load a result from the optimizer back into the input fields
function loadOptimizerResult(index) {
    const result = window.optimizerResults[index];
    
    // Set the strategy dropdown
    document.getElementById('strategy').value = 'fixed';
    
    // Set the nYears parameter
    document.getElementById('nYears').value = result.parameter;
    
    // Show the correct UI section
    toggleStrategyUI();
    
    // Run the simulation to update the display
	runSimulation(); 
	showTab('tab-tbl')
}

// //////////////////////////////////////////////////////////////////

// Column category mappings - each column can be in multiple categories
const columnCategories = {
    // Summary - high-level overview
    'year': ['Summary'],
    'age1': ['Summary'],
    'age2': ['Summary'],
    'status': ['Summary'],
    'spendGoal': ['Summary'],
    'netIncome': ['Summary'],
    'totalWealth': ['Summary', 'Balances'],
    'totalTax': ['Summary', 'Taxation'],
    'NominalRate%': ['Summary', 'Taxation'],
    'surplus': ['Summary'],
    
    // Income Sources (could be its own category if you want)
    'SSincome': ['Summary'],
    'pension': ['Summary'],
    'totalIncome': ['Summary', 'Taxation'],
    'cashD+I': ['Cash Î”', 'Taxation'],
    
    // Balances - end-of-year balances
    'IRA1': ['Balances', 'IRA Î”'],
    'IRA2': ['Balances', 'IRA Î”'],
    'TotalIRA': ['Balances', 'IRA Î”'],
    'Cash': ['Balances', 'Cash Î”'],
    'Roth': ['Balances', 'Roth Î”'],
    'Brokerage': ['Balances', 'Brokerage Î”'],
    'Basis': ['Balances', 'Brokerage Î”'],
    'Spendable': ['Balances'],
    
    // Taxation
    'magi': ['Taxation'],
    'IRMAA': ['Taxation'],
    'FedTax': ['Taxation'],
    'StateTax': ['Taxation'],
    'CapGains': ['Taxation', 'Brokerage Î”'],
    'SumTaxes': ['Taxation'],
    'FedRate%': ['Taxation'],
    'StateRate%': ['Taxation'],
    'fedLimit': ['Taxation'],
    'stateLimit': ['Taxation'],
    
    // IRA Changes - withdrawals, RMDs, and conversions
    'IRA1-': ['IRA Î”'],
    'IRA2-': ['IRA Î”'],
    'RMD%': ['IRA Î”'],
    'RMD1-': ['IRA Î”'],
    'RMD2-': ['IRA Î”'],
    '-RMDwd': ['IRA Î”'],
    'rothConv': ['IRA Î”', 'Roth Î”'],  // Conversion comes from IRA
    
    // Roth Changes - balance, withdrawals, growth, conversions
    'RothWD': ['Roth Î”'],
    'rothG': ['Roth Î”'],
    
    // Brokerage Changes - balance, withdrawals, gains, growth
    'Brokerage-': ['Brokerage Î”'],
    'brokerageG': ['Brokerage Î”'],
    
    // Cash Changes - balance, withdrawals, growth
    'CashWD': ['Cash Î”'],
    'cashG': ['Cash Î”']
};

// Get active categories based on checkbox state
function getActiveCategories() {
    const categories = [];
    if (document.getElementById('cat-summary')?.checked) categories.push('Summary');
    if (document.getElementById('cat-balances')?.checked) categories.push('Balances');
    if (document.getElementById('cat-taxation')?.checked) categories.push('Taxation');
    if (document.getElementById('cat-ira')?.checked) categories.push('IRA Î”');
    if (document.getElementById('cat-roth')?.checked) categories.push('Roth Î”');
    if (document.getElementById('cat-brokerage')?.checked) categories.push('Brokerage Î”');
    if (document.getElementById('cat-cash')?.checked) categories.push('Cash Î”');
    return categories;
}

// Check if a column should be visible based on category filters
function isColumnVisible(columnKey) {
    const showAll = document.getElementById('show-all')?.checked ?? false;
    
    if (showAll) {
        // Show all columns that are listed in at least one category
        return columnCategories.hasOwnProperty(columnKey);
    }
    
    const activeCategories = getActiveCategories();
    
    // Column is not categorized - hide it
    if (!columnCategories.hasOwnProperty(columnKey)) {
        return false;
    }
    
    // Check if column is in any active category
    const columnCats = columnCategories[columnKey];
    return columnCats.some(cat => activeCategories.includes(cat));
}

// Analyze which columns have content (non-zero, non-empty values)
function analyzeColumnContent(log) {
    if (!log || log.length === 0) return {};
    
    const keys = Object.keys(log[0]).filter(key => !key.startsWith('-'));
    const columnStatus = {};
    
    keys.forEach(key => {
        let hasNonZeroValue = false;
        
        for (const row of log) {
            const value = row[key];
            
            // Check if value exists and is non-zero
            if (value != null && value !== '' && value !== 'â€”') {
                if (!isNaN(value) && parseFloat(value) !== 0) {
                    hasNonZeroValue = true;
                    break;
                } else if (isNaN(value) && value !== 'â€”') {
                    // Non-numeric non-empty value
                    hasNonZeroValue = true;
                    break;
                }
            }
        }
        
        columnStatus[key] = hasNonZeroValue;
    });
    
    return columnStatus;
}

// Global variable to store column content analysis
let columnContentStatus = {};

// Update column visibility without rebuilding the entire table
function updateColumnVisibility() {
    const table = document.getElementById('main-table');
    if (!table) return;
    
    const headerRow = table.querySelector('thead tr');
    const bodyRows = table.querySelectorAll('tbody tr');
    
    if (!headerRow) return;
    
    const showEmpty = document.getElementById('show-empty-columns')?.checked ?? false;
    
    // Get column keys from header
    const headers = Array.from(headerRow.querySelectorAll('th'));
    
    headers.forEach((th, index) => {
        const columnKey = th.textContent;
        const visibleByCategory = isColumnVisible(columnKey);
        const isEmpty = th.classList.contains('empty-column');
        
        // Column is visible if it passes category filter AND (has content OR show-empty is checked)
        const visible = visibleByCategory && (showEmpty || !isEmpty);
        
        // Update header
        if (visible) {
            th.classList.remove('hidden-column');
        } else {
            th.classList.add('hidden-column');
        }
        
        // Update all body cells in this column
        bodyRows.forEach(row => {
            const cell = row.cells[index];
            if (cell) {
                if (visible) {
                    cell.classList.remove('hidden-column');
                } else {
                    cell.classList.add('hidden-column');
                }
            }
        });
    });
}

function updateTable(log) {
    const oldTable = document.getElementById('main-table');

    if (!log || log.length === 0) {
        if (oldTable) {
          oldTable.remove();
        }
        return null;
    }

    // Analyze which columns have content
    columnContentStatus = analyzeColumnContent(log);

    const table = document.createElement('table');
    table.border = '1';
    table.id = 'main-table';
  
    const keys = Object.keys(log[0]);

    // Create header
    const thead = table.createTHead();
    const headerRow = thead.insertRow();
    
    const tooltips = {
        'year': 'A pink row means insufficient funds. A yellow row is for a single survivor',
        'RMDwd': 'Total of all RMDs (positive indicate withdrawals)',
        'RMD%': 'The highest percentage RMD required for IRA1 or IRA2.',
        'Brokerage': 'Year end Brokerage balance',
        'Brokerage-': 'Withdrawals from Brokerage account (sales)',
        'Basis': 'The amount in brokerage which can be withdrawn tax free.',
        'IRA1-': 'Withdrawals from IRA1',
        'IRA2-': 'Withdrawals from IRA2',
        'CapGains': 'Amount of gains from selling brokerage assets.',
        'IRMAA': 'First two years are presumed the same as the 3rd year on.',
        'spendGoal': 'This amount increases by inflation less Spend Delta%.',
        'Roth': 'Balance at Year End',
        'RothG': 'Growth in the Roth (added to Roth account)',
        'RothConv': 'Amount moved from IRA to Roth (converted)',
        'CashWD': 'Tax free withdrawals from Cash',
        'cashD+I': 'Dividends (from brokerage) and interest from Cash (deposits)',
        'magi': 'Modified Adjusted Gross Income - determines future IRMAA',
        'totalTax': 'Federal,IRMAA,NIIT,CapGains & IRMAA - in total.',
        'SumTaxes': 'Running total of Federal,IRMAA,NIIT,CapGains & IRMAA.',
        'NominalRate%': 'TotalTax/TotalGrossIncome for all taxes - Fed, State, IRMAA'
    };

    keys.forEach(key => {
        if (!key.startsWith('-')) {
            const th = document.createElement('th');
            const displayKey = key.endsWith('!') ? key.slice(0, -1) : key;
            th.textContent = displayKey;
            
            if (tooltips[key]) {
                th.title = tooltips[key];
            }
            
            // Apply visibility based on category filter AND empty column filter
            const visibleByCategory = isColumnVisible(displayKey);
            const hasContent = columnContentStatus[key];
            const showEmpty = document.getElementById('show-empty-columns')?.checked ?? false;
            
            if (!visibleByCategory || (!hasContent && !showEmpty)) {
                th.classList.add('hidden-column');
            }
            
            // Mark empty columns for styling
            if (!hasContent) {
                th.classList.add('empty-column');
            }
            
            headerRow.appendChild(th);
        }
    });
  
    // Create body
    const tbody = table.createTBody();
    log.forEach(row => {
      const tr = tbody.insertRow();
      
      // Check conditions for highlighting
      const spendGoal = row['SpendGoal'] ?? row['spendGoal'];
      const netIncome = row['NetIncome'] ?? row['netIncome'];
      const totalWealth = row['TotalWealth'] ?? row['totalWealth'];
      const age1 = row['Age1'] ?? row['age1'];
      const age2 = row['Age2'] ?? row['age2'];
      
      const shouldHighlightPink = (spendGoal > netIncome) || (totalWealth < spendGoal);
      const shouldHighlightYellow = (age1 === 'â€”' || age2 === 'â€”');
      
      // Pink takes priority over yellow
      if (shouldHighlightPink) {
        tr.style.backgroundColor = '#ffb6c180';  // Light pink
      } else if (shouldHighlightYellow) {
        tr.style.backgroundColor = '#ffff99';  // Light yellow
      }
      
      keys.forEach(key => {
        if (!key.startsWith('-')) {
          const td = tr.insertCell();
          const value = row[key];
          
          // Check if key indicates percentage
          const isPercent = key.toLowerCase().includes('%');
          const isYear = key.toLowerCase().includes('yr') || key.toLowerCase().includes('year');
          
          if (value != null && !isNaN(value)) {
            if (isPercent) {
              // Format as percentage (convert from decimal)
              td.textContent = (value * 100).toFixed(2);
            } else {
              // Format as whole number
              if (isYear) {
                td.textContent = value;
              } else {
                td.textContent = Math.round(value).toLocaleString();
              }
            }
          } else {
            td.textContent = value ?? '';
          }
          
          // Apply visibility based on category filter AND empty column filter
          const displayKey = key.endsWith('!') ? key.slice(0, -1) : key;
          const visibleByCategory = isColumnVisible(displayKey);
          const hasContent = columnContentStatus[key];
          const showEmpty = document.getElementById('show-empty-columns')?.checked ?? false;
          
          if (!visibleByCategory || (!hasContent && !showEmpty)) {
            td.classList.add('hidden-column');
          }
          
          // Mark empty columns for styling
          if (!hasContent) {
            td.classList.add('empty-column');
          }
          
          tr.appendChild(td);
        }
      });
    });
  
    if (oldTable) {
        oldTable.replaceWith(table);
    }
  
    return table;
}



/*****************************

// Add this function to detect empty or all-zero columns
function analyzeColumnContent(log) {
    if (!log || log.length === 0) return {};
    
    const keys = Object.keys(log[0]).filter(key => !key.startsWith('-'));
    const columnStatus = {};
    
    keys.forEach(key => {
        let hasNonZeroValue = false;
        
        for (const row of log) {
            const value = row[key];
            
            // Check if value exists and is non-zero
            if (value != null && value !== '' && value !== 'â€”') {
                if (!isNaN(value) && parseFloat(value) !== 0) {
                    hasNonZeroValue = true;
                    break;
                } else if (isNaN(value) && value !== 'â€”') {
                    // Non-numeric non-empty value
                    hasNonZeroValue = true;
                    break;
                }
            }
        }
        
        columnStatus[key] = hasNonZeroValue;
    });
    
    return columnStatus;
}

// Global variable to store column content analysis
let columnContentStatus = {};

function updateTable(log) {
    const oldTable = document.getElementById('main-table');

    if (!log || log.length === 0) {
        if (oldTable) {
          oldTable.remove();
        }
        return null;
    }

    // Analyze which columns have content
    columnContentStatus = analyzeColumnContent(log);

    const table = document.createElement('table');
    table.border = '1';
    table.id = 'main-table';
  
    const keys = Object.keys(log[0]);

    // Create header
    const thead = table.createTHead();
    const headerRow = thead.insertRow();
    
    const tooltips = {
        'year': 'A pink row means insufficient funds. A yellow row is for a single survivor',
        'RMDwd': 'Total of all RMDs (positive indicate withdrawals)',
        'RMD%': 'The highest percentage RMD required for IRA1 or IRA2.',
        'Brokerage': 'Year end Brokerage balance',
        'Brokerage-': 'Withdrawals from Brokerage account (sales)',
        'Basis': 'The amount in brokerage which can be withdrawn tax free.',
        'IRA1-': 'Withdrawals from IRA1',
        'IRA2-': 'Withdrawals from IRA2',
        'CapGains': 'Amount of gains from selling brokerage assets.',
        'IRMAA': 'First two years are presumed the same as the 3rd year on.',
        'spendGoal': 'This amount increases by inflation less Spend Delta%.',
        'Roth': 'Balance at Year End',
        'RothG': 'Growth in the Roth (added to Roth account)',
        'RothConv': 'Amount moved from IRA to Roth (converted)',
        'CashWD': 'Tax free withdrawals from Cash',
        'cashD+I': 'Dividends (from brokerage) and interest from Cash (deposits)',
        'magi': 'Modified Adjusted Gross Income - determines future IRMAA',
        'totalTax': 'Federal,IRMAA,NIIT,CapGains & IRMAA - in total.',
        'SumTaxes': 'Running total of Federal,IRMAA,NIIT,CapGains & IRMAA.',
        'NominalRate%': 'TotalTax/TotalGrossIncome for all taxes - Fed, State, IRMAA'
    };

    keys.forEach(key => {
        if (!key.startsWith('-')) {
            const th = document.createElement('th');
            const displayKey = key.endsWith('!') ? key.slice(0, -1) : key;
            th.textContent = displayKey;
            
            if (tooltips[key]) {
                th.title = tooltips[key];
            }
            
            // Apply visibility based on category filter AND empty column filter
            const visibleByCategory = typeof isColumnVisible === 'function' ? isColumnVisible(displayKey) : true;
            const hasContent = columnContentStatus[key];
            const showEmpty = document.getElementById('show-empty-columns')?.checked ?? false;
            
            if (!visibleByCategory || (!hasContent && !showEmpty)) {
                th.classList.add('hidden-column');
            }
            
            // Mark empty columns for styling
            if (!hasContent) {
                th.classList.add('empty-column');
            }
            
            headerRow.appendChild(th);
        }
    });
  
    // Create body
    const tbody = table.createTBody();
    log.forEach(row => {
      const tr = tbody.insertRow();
      
      // Check conditions for highlighting
      const spendGoal = row['SpendGoal'] ?? row['spendGoal'];
      const netIncome = row['NetIncome'] ?? row['netIncome'];
      const totalWealth = row['TotalWealth'] ?? row['totalWealth'];
      const age1 = row['Age1'] ?? row['age1'];
      const age2 = row['Age2'] ?? row['age2'];
      
      const shouldHighlightPink = (spendGoal > netIncome) || (totalWealth < spendGoal);
      const shouldHighlightYellow = (age1 === 'â€”' || age2 === 'â€”');
      
      // Pink takes priority over yellow
      if (shouldHighlightPink) {
        tr.style.backgroundColor = '#ffb6c180';  // Light pink
      } else if (shouldHighlightYellow) {
        tr.style.backgroundColor = '#ffff99';  // Light yellow
      }
      
      keys.forEach(key => {
        if (!key.startsWith('-')) {
          const td = tr.insertCell();
          const value = row[key];
          
          // Check if key indicates percentage
          const isPercent = key.toLowerCase().includes('%');
          const isYear = key.toLowerCase().includes('yr') || key.toLowerCase().includes('year');
          
          if (value != null && !isNaN(value)) {
            if (isPercent) {
              // Format as percentage (convert from decimal)
              td.textContent = (value * 100).toFixed(2);
            } else {
              // Format as whole number
              if (isYear) {
                td.textContent = value;
              } else {
                td.textContent = Math.round(value).toLocaleString();
              }
            }
          } else {
            td.textContent = value ?? '';
          }
          
          // Apply visibility based on category filter AND empty column filter
          const displayKey = key.endsWith('!') ? key.slice(0, -1) : key;
          const visibleByCategory = typeof isColumnVisible === 'function' ? isColumnVisible(displayKey) : true;
          const hasContent = columnContentStatus[key];
          const showEmpty = document.getElementById('show-empty-columns')?.checked ?? false;
          
          if (!visibleByCategory || (!hasContent && !showEmpty)) {
            td.classList.add('hidden-column');
          }
          
          // Mark empty columns for styling
          if (!hasContent) {
            td.classList.add('empty-column');
          }
          
          tr.appendChild(td);
        }
      });
    });
  
    if (oldTable) {
        oldTable.replaceWith(table);
    }
  
    return table;
}

// Update the visibility function to handle both category and empty column filters
function updateColumnVisibility() {
    const table = document.getElementById('main-table');
    if (!table) return;
    
    const headerRow = table.querySelector('thead tr');
    const bodyRows = table.querySelectorAll('tbody tr');
    
    if (!headerRow) return;
    
    const showEmpty = document.getElementById('show-empty-columns')?.checked ?? false;
    
    // Get column keys from header
    const headers = Array.from(headerRow.querySelectorAll('th'));
    
    headers.forEach((th, index) => {
        const columnKey = th.textContent;
        const visibleByCategory = isColumnVisible(columnKey);
        const isEmpty = th.classList.contains('empty-column');
        
        // Column is visible if it passes category filter AND (has content OR show-empty is checked)
        const visible = visibleByCategory && (showEmpty || !isEmpty);
        
        // Update header
        if (visible) {
            th.classList.remove('hidden-column');
        } else {
            th.classList.add('hidden-column');
        }
        
        // Update all body cells in this column
        bodyRows.forEach(row => {
            const cell = row.cells[index];
            if (cell) {
                if (visible) {
                    cell.classList.remove('hidden-column');
                } else {
                    cell.classList.add('hidden-column');
                }
            }
        });
    });
}


/* OLD FUNCTION
function updateTable(log) {
	const oldTable = document.getElementById('main-table');

	if (!log || log.length === 0) {
		if (oldTable) {
		  oldTable.remove();
		}
		return null;
	}

	const table = document.createElement('table');
	table.border = '1';
	table.id = 'main-table';
  
	const keys = Object.keys(log[0]);

	// Create header
	const thead = table.createTHead();
	const headerRow = thead.insertRow();
	
	const tooltips = {
		'year': 'A pink row means insufficient funds. A yellow row is for a single survivor',
		'RMDwd': 'Total of all RMDs (positive indicate withdrawals)',
		'RMD%': 'The highest percentage RMD required for IRA1 or IRA2.',
		'Brokerage': 'Year end Brokerage balance',
		'Brokerage-': 'Withdrawals from Brokerage account (sales)',
		'Basis': 'The amount in brokerage which can be withdrawn tax free.',
		'IRA1-': 'Withrdrawals from IRA1',
		'IRA2-': 'Withrdrawals from IRA2',
		'CapGains': 'Amount of gains from selling brokerage assets.',
		'IRMAA': 'First two years are presumed the same as the 3rd year on.',
		'spendGoal': 'This amount increases by inflation less Spend Delta%.',
		'Roth': 'Balance at Year End',
		'RothG': 'Growth in the Roth (added to Roth account)',
		'RothG': 'Growth in the Roth (added to Roth account)',
		'RothConv': 'Amount moved from IRA to Roth (converted)',
		'CashWD': 'Tax free withdrawals from Cash',
		'cashD+I': 'Dividends (from brokerage) and interest from Cash (deposits)',
		'magi': 'Modified Adjusted Gross Income - determines future IRMAA',
		'totalTax': 'Federal,IRMAA,NIIT,CapGains & IRMAA - in total.',
		'SumTaxes': 'Running total of Federal,IRMAA,NIIT,CapGains & IRMAA.',
		'NominalRate%': 'TotalTax/TotalGrossIncome for all taxes - Fed, State, IRMAA'
	};

	keys.forEach(key => {
		if (!key.startsWith('-')) {
			const th = document.createElement('th');
			th.textContent = key.endsWith('!') ? key.slice(0, -1) : key;
			
			if (tooltips[key]) {
				th.title = tooltips[key];
			}
			
			headerRow.appendChild(th);
		}
	});
  
	// Create body
	const tbody = table.createTBody();
	log.forEach(row => {
	  const tr = tbody.insertRow();
	  
	  // Check conditions for highlighting
	  const spendGoal = row['SpendGoal'] ?? row['spendGoal'];
	  const netIncome = row['NetIncome'] ?? row['netIncome'];
	  const totalWealth = row['TotalWealth'] ?? row['totalWealth'];
	  const age1 = row['Age1'] ?? row['age1'];
	  const age2 = row['Age2'] ?? row['age2'];
	  
	  const shouldHighlightPink = (spendGoal > netIncome) || (totalWealth < spendGoal);
	  const shouldHighlightYellow = (age1 === 'â€”' || age2 === 'â€”');
	  
	  // Pink takes priority over yellow
	  if (shouldHighlightPink) {
		tr.style.backgroundColor = '#ffb6c180';  // Light pink
	  } else if (shouldHighlightYellow) {
		tr.style.backgroundColor = '#ffff99';  // Light yellow
	  }
	  
	  keys.forEach(key => {
		if (!key.startsWith('-')) {
		  const td = tr.insertCell();
		  const value = row[key];
		  
		  // Check if key indicates percentage
		  const isPercent = key.toLowerCase().includes('%');
		  const isYear = key.toLowerCase().includes('yr') || key.toLowerCase().includes('year');
		  
		  if (value != null && !isNaN(value)) {
			if (isPercent) {
			  // Format as percentage (convert from decimal)
			  td.textContent = (value * 100).toFixed(2);
			} else {
			  // Format as whole number
			  if (isYear) {
				td.textContent = value;
			  } else {
				td.textContent = Math.round(value).toLocaleString();
			  }
			}
		  } else {
			td.textContent = value ?? '';
		  }
		  
		  tr.appendChild(td);
		}
	  });
	});
  
  if (oldTable) {
    oldTable.replaceWith(table);
  }
  
  return table;
}
END OLD FUNCTION */

/*calculateInflationAdjustedWithdrawal:
* given the parameters, determines the first year withdrawal (subsequent years are 
* adjusted for inflation).  At that rate, the asset would reach zero in *years*
*/
function calculateInflationAdjustedWithdrawal(principal, growthRate, inflationRate, years) {
    // Calculate real growth rate
    const realRate = growthRate - inflationRate;
	
	// Special case: principal is negative.
	if (principal <= 0) return 0;
    
    // Special case: when real growth is zero
    if (Math.abs(realRate) < 0.0001) {
        return principal / years;
    }
    
    // General case: first year withdrawal in today's dollars
    const denominator = 1 - Math.pow(1 + realRate, -years);
    const firstYearWithdrawal = principal * (realRate / denominator);
    
    return firstYearWithdrawal;
}


function updateStats(totals, finalNW, minNetWorth = 100000) {
    document.getElementById('stat-rate').innerText = (totals.tax / totals.gross * 100).toFixed(1) + '%';
    document.getElementById('stat-spend').innerText = '$' + Math.round(totals.spend).toLocaleString();
    document.getElementById('stat-tax').innerText = '$' + Math.round(totals.tax).toLocaleString();
    document.getElementById('stat-nw').innerText = '$' + Math.round(finalNW).toLocaleString();
    document.getElementById('stat-years').innerText = totals.yearsfunded + '/' + totals.yearstested;
    // document.getElementById('stat-yearsfunded').innerText = totals.yearsfunded;
	let indicator = 'ðŸ›‘ FAILED ';
	if (totals.yearsfunded >= totals.yearstested && finalNW > minNetWorth) {
		indicator = 'ðŸŸ¢ SUCCESS ';
	}
    document.getElementById('stat-success').innerText = indicator;

}

let assetChart, taxChart;
function updateCharts(log) {
    const ctxA = document.getElementById('chartAssets').getContext('2d');
    if (assetChart) assetChart.destroy();
    assetChart = new Chart(ctxA, {
        type: 'line',
        data: {
            labels: log.map(r => r.year),
            datasets: [
                { label: 'IRAs', data: log.map(r => r.TotalIRA), borderColor: '#e67e22', fill: false },
                { label: 'Roth', data: log.map(r => r.Roth), borderColor: '#000000', fill: false },
                { label: 'Brokerage', data: log.map(r => r.Brokerage), borderColor: '#2980b9', fill: false },
                { label: 'Cash', data: log.map(r => r.Cash), borderColor: '#27ae60', fill: false },
                { label: 'TotalWealth', data: log.map(r => r.totalWealth), borderColor: '#888888', fill: false }
            ]
        },
        options: {
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return context.dataset.label + ': ' + 
                                   Math.round(context.parsed.y).toLocaleString();
                        }
                    }
                }
/*				,
			  legend: {
				labels: {
				  usePointStyle: true,
				  pointStyle: 'circle',
					fill: false,
				  boxWidth: 10,
				  boxHeight: 10,

				  padding: 16
					}
				} // legend
*/
            } // plugins
        } // options
    });
    
    const ctxT = document.getElementById('chartTaxSpend').getContext('2d');
    if (taxChart) taxChart.destroy();
taxChart = new Chart(ctxT, {
    data: {  // Removed type from here
        labels: log.map(r => r.year),
        datasets: [
            { 
                label: 'Fed Tax', 
                data: log.map(r => r.FedTax),
                type: 'bar',  // Type on dataset
                backgroundColor: '#e74c3c80',
                stack: 'taxes',
                order: 2
            },
            { 
                label: 'State Tax', 
                data: log.map(r => r.StateTax),
                type: 'bar',  // Type on dataset
                backgroundColor: '#4BC0C0B3',
                stack: 'taxes',
                order: 2
            },
            { 
                label: 'IRMAA', 
                data: log.map(r => r.IRMAA),
                type: 'bar',  // Type on dataset
                backgroundColor: '#000000D0',
                stack: 'taxes',
                order: 2
            },

/*			
            { 
                label: 'Fixed Income', 
                data: log.map(r => r.pension + r.SSincome),
                type: 'line',  // Type on dataset
                borderColor: '#272727', 
                fill: false, 
				stack: false,
                borderWidth: 3,
                order: 1
                // NO stack property
            },
*/			
            { 
                label: 'Spendable Income', 
                data: log.map(r => r.netIncome),
                type: 'line',  // Type on dataset
                borderColor: '#27ae60', 
                fill: false, 
				stack: false,
                borderWidth: 3,
                order: 1
                // NO stack property
            }
        ]
    },
    options: {
        scales: {
            x: {
                stacked: true
            },
            y: {
                stacked: true,
                ticks: {
                    callback: function(value) {
                        return Math.round(value).toLocaleString();
                    }
                }
            }
        },
        plugins: {
			tooltip: {
				callbacks: {
					label: function(context) {
						return context.dataset.label + ': ' + 
							   Math.round(context.parsed.y).toLocaleString();
					}
				}
			},
		  legend: {
			labels: {
			  usePointStyle: true,
			  pointStyle: 'circle',

			  boxWidth: 10,
			  boxHeight: 10,

			  padding: 16
				}
			} // legend
		} // plugins
	} // options
	});	// chart
}

function val(id) { return document.getElementById(id)?.value; }
function valChecked(id) { return document.getElementById(id)?.checked; }


function showTab(id) {
    // 1. Hide all tab content cards
    document.querySelectorAll('.tab-content, .card').forEach(c => { 
        if(c.id.startsWith('tab-')) c.classList.add('hidden'); 
    });
    // 2. Show the selected card
    document.getElementById(id).classList.remove('hidden');

    // 3. Update the active button styling (Fixed Selector)
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    const activeBtn = document.querySelector(`.tab-btn[onclick*="${id}"]`);
    if (activeBtn) activeBtn.classList.add('active');
}


function toggleStrategyUI() {
    let m = val('strategy');
    document.getElementById('ui-fixed').classList.toggle('hidden', m !== 'fixed');
    document.getElementById('ui-bracket').classList.toggle('hidden', m !== 'bracket' && m !== 'minlimit');
	// document.getElementById('ui-maximize').classList.toggle('hidden', !(m === 'baseline'));
}


/* Save, Import and Export settings/Scenarios
*/
///////////////////////////////////////////////
// ============================================================================


// ============================================================================
// MESSAGE DISPLAY FUNCTIONS
// ============================================================================

/**
 * Displays a colored message in the scenario message area
 * @param {string} message - The text message to display
 * @param {string} type - Message type: 'success' (green), 'error' (red), or 'warning' (yellow)
 *                        Default is 'success'
 * Auto-hides the message after 5 seconds
 */
function showMessage(message, type = 'success') {
    const messageDiv = document.getElementById('popUpMessage');
    messageDiv.textContent = message;
    messageDiv.className = `scenario-message ${type}`;
    messageDiv.style.display = 'block';
    
    // Auto-hide after 15 seconds
    setTimeout(() => {
        messageDiv.style.display = 'none';
    }, 15000);
}

/**
 * Manually clears and hides the message display area
 * No parameters
 */
function clearMessage() {
    const messageDiv = document.getElementById('popUpMessage');
    messageDiv.style.display = 'none';
}

// ============================================================================
// STORAGE ACCESS FUNCTIONS
// ============================================================================

/**
 * Retrieves all scenarios from the new storage key
 * No parameters
 * @returns {Object} Object containing scenario data keyed by scenario name
 *                   Returns empty object {} if no scenarios exist
 */
function getSavedScenarios() {
    const saved = localStorage.getItem(STORAGE_KEY);
    return saved ? JSON.parse(saved) : {};
}

/**
 * Retrieves all scenarios from the old storage key (previous version)
 * No parameters
 * @returns {Object} Object containing old scenario data keyed by scenario name
 *                   Returns empty object {} if no old scenarios exist
 */
function getOldScenarios() {
    const oldSaved = localStorage.getItem(OLD_STORAGE_KEY);
    return oldSaved ? JSON.parse(oldSaved) : {};
}

/**
 * Retrieves and merges scenarios from both old and new storage locations
 * Old scenarios are marked with isOldStorage flag and version 1
 * No parameters
 * @returns {Object} Merged object containing all scenarios from both storage keys
 *                   Old scenarios have isOldStorage: true property added
 */
function getAllScenarios() {
    const newScenarios = getSavedScenarios();
    const oldScenarios = getOldScenarios();
    
    // Merge old scenarios, marking them as version 1
    const allScenarios = { ...newScenarios };
    
    for (const [name, scenario] of Object.entries(oldScenarios)) {
        // If scenario doesn't have a version property, it's from old version
        if (!scenario.version) {
            allScenarios[name] = {
                version: 1,
                data: scenario.data || scenario, // Handle different old formats
                savedAt: scenario.savedAt || 'Unknown',
                isOldStorage: true // Flag to identify old storage scenarios
            };
        }
    }
    
    return allScenarios;
}

// ============================================================================
// SCENARIO VALIDATION FUNCTIONS
// ============================================================================

/**
 * Checks if a scenario is compatible with the current version
 * @param {Object} scenario - Scenario object with version property
 * @returns {boolean} True if scenario.version matches SCENARIO_VERSION, false otherwise
 */
function isCompatibleScenario(scenario) {
    return scenario.version === SCENARIO_VERSION;
}

/**
 * Escapes single and double quotes in a string for safe use in HTML attributes
 * @param {string} str - String to escape
 * @returns {string} String with ' replaced by \' and " replaced by \"
 */
function escapeQuotes(str) {
    return str.replace(/'/g, "\\'").replace(/"/g, '\\"');
}


// ============================================================================
// MAIN USER ACTION FUNCTIONS
// ============================================================================

/**
 * Saves current form inputs as a named scenario to new storage
 * Uses scenario name from input field #scenarioName, or generates timestamp name if empty
 * Calls getInputs() to retrieve current form values
 * Displays success or error message
 * No parameters
 */
function saveScenario() {
    const inputs = getInputs();
	const scenarioName = document.getElementById('scenarioName').value.trim() || 
                    `${new Date().toISOString().slice(0, 19).replace('T', ' ')}`;
    
    try {
        const scenarios = getSavedScenarios();
        
        scenarios[scenarioName] = {
            version: SCENARIO_VERSION,
            data: inputs,
            savedAt: new Date().toISOString()
        };
        
        localStorage.setItem(STORAGE_KEY, JSON.stringify(scenarios));
        
        showMessage(`Scenario "${scenarioName}" saved successfully!`, 'success');
        document.getElementById('scenarioName').value = '';
    } catch (error) {
        showMessage(`Failed to save scenario: ${error.message}`, 'error');
    }
}

/**
 * Prompts user to select and load a compatible scenario
 * Filters out incompatible versions before displaying list
 * Shows error if no compatible scenarios exist
 * No parameters
 */
function loadScenario() {
    try {
        const scenarios = getSavedScenarios();
        const scenarioNames = Object.keys(scenarios);
        
        if (scenarioNames.length === 0) {
            showMessage('No saved scenarios found.', 'error');
            return;
        }
        
        const compatibleScenarios = scenarioNames.filter(name => 
            scenarios[name].version === SCENARIO_VERSION
        );
        
        if (compatibleScenarios.length === 0) {
            showMessage('No compatible scenarios found. All saved scenarios are from an older version.', 'error');
            return;
        }
        
        let selection = prompt('Enter scenario name to load:\n\n' + compatibleScenarios.join('\n'));
        
        if (selection && scenarios[selection]) {
            if (scenarios[selection].version !== SCENARIO_VERSION) {
                showMessage('This scenario is from an incompatible version and cannot be loaded.', 'error');
                return;
            }
            applyScenario(scenarios[selection].data);
            showMessage(`Scenario "${selection}" loaded successfully!`, 'success');
        } else if (selection) {
            showMessage('Scenario not found.', 'error');
        }
    } catch (error) {
        showMessage(`Failed to load scenario: ${error.message}`, 'error');
    }
}

/**
 * Applies scenario data to form input fields
 * Handles percentage conversions for specific fields (multiplies by 100 for display)
 * Triggers recalculate() function if it exists
 * @param {Object} data - Scenario data object with keys matching form input IDs
 */
function applyScenario(data) {
    for (const [key, value] of Object.entries(data)) {
        const element = document.getElementById(key);
        if (element) {
            // Handle percentage values (multiply by 100 for display)
            if (['stratRate', 'spendChange', 'inflation', 'cpi', 'growth', 
                 'cashYield', 'dividendRate', 'ssFailPct'].includes(key)) {
                element.value = (value * 100).toFixed(3);
            } else {
				if (['maxConversion'].includes(key)) {
					document.getElementById('maxConversion').checked = value
				} else { 
					element.value = value;
				}
            }
        }
    }
    
    // Trigger any recalculations your app needs
    if (typeof runSimulation === 'function') {
        runSimulation();
    }
}

// ============================================================================
// SCENARIO MANAGEMENT FUNCTIONS
// ============================================================================

/**
 * Opens modal dialog showing all scenarios from both storage locations
 * Displays table with Name, Saved Date, Version, Storage location, and Actions
 * Shows compatibility status with color coding (green=compatible, red=incompatible)
 * Shows bulk action buttons if incompatible or old scenarios exist
 * No parameters
 */
function manageScenarios() {
    const scenarios = getAllScenarios();
    const modal = document.getElementById('scenarioModal');
    const content = document.getElementById('scenarioListContent');
    
    if (Object.keys(scenarios).length === 0) {
        content.innerHTML = '<p>No saved scenarios.</p>';
    } else {
        let html = '<table style="width: 100%; border-collapse: collapse;">';
        html += '<tr><th style="text-align: left; padding: 8px; border-bottom: 2px solid #ddd;">Name</th>';
        html += '<th style="text-align: left; padding: 8px; border-bottom: 2px solid #ddd;">Saved</th>';
        html += '<th style="text-align: center; padding: 8px; border-bottom: 2px solid #ddd;">Version</th>';
        html += '<th style="text-align: center; padding: 8px; border-bottom: 2px solid #ddd;">Actions</th></tr>';
        
        for (const [name, scenario] of Object.entries(scenarios)) {
            const savedDate = scenario.savedAt !== 'Unknown' 
                ? new Date(scenario.savedAt).toLocaleString() 
                : 'Unknown';
            const version = scenario.version || 1;
            const isCurrent = version === SCENARIO_VERSION;
            const isOldStorage = scenario.isOldStorage || false;
            
            const versionBadge = isCurrent 
                ? `<span style="color: green; font-weight: bold;">v${version} âœ“</span>` 
                : `<span style="color: red;">v${version} âœ—</span>`;
            
            const storageBadge = isOldStorage
                ? `<span style="color: orange; font-size: 0.9em;">OLD</span>`
                : `<span style="color: blue; font-size: 0.9em;">NEW</span>`;
            
            const rowStyle = isCurrent ? '' : 'background-color: #ffeeee;';
            
            html += `<tr style="${rowStyle}">
                <td style="padding: 4px; border-bottom: 1px solid #eee;">${name}</td>
                <td style="padding: 4px; border-bottom: 1px solid #eee;">${savedDate}</td>
                <td style="padding: 4px; border-bottom: 1px solid #eee; text-align: center;">${versionBadge}</td>
                <td style="padding: 8px; border-bottom: 1px solid #eee; text-align: center;">
					<button class="modal-btn" onclick="loadScenarioByName('${escapeQuotes(name)}')" ${!isCurrent ? 'disabled title="Incompatible version"' : ''}>Load</button>
					<button class="modal-btn" onclick="deleteScenario('${escapeQuotes(name)}')">Delete</button>
					<button class="modal-btn" onclick="exportScenario('${escapeQuotes(name)}')">Export</button>
                </td>
            </tr>`;
        }
        html += '</table>';
        
        const incompatibleCount = Object.values(scenarios).filter(s => !isCompatibleScenario(s)).length;
        const oldStorageCount = Object.values(scenarios).filter(s => s.isOldStorage).length;
        
        if (incompatibleCount > 0 || oldStorageCount > 0) {
            html += `<div style="margin-top: 15px; padding: 10px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px;">`;
            
            if (incompatibleCount > 0) {
                html += `<strong>âš ï¸ ${incompatibleCount} incompatible scenario(s) found</strong><br>`;
            }
            if (oldStorageCount > 0) {
                html += `<strong>ðŸ“¦ ${oldStorageCount} scenario(s) in old storage format</strong><br>`;
            }
            
            html += `<button onclick="deleteIncompatibleScenarios()" style="margin-top: 5px;">Delete All Incompatible Scenarios</button>`;          
           
            html += `</div>`;
        }
        
        content.innerHTML = html;
    }
    
    modal.style.display = 'block';
}

/**
 * Loads a specific scenario by name from either storage location
 * Validates version compatibility before loading
 * Closes modal and shows success/error message
 * @param {string} name - Name of the scenario to load
 */
function loadScenarioByName(name) {
    try {
        const scenarios = getAllScenarios();
        if (scenarios[name]) {
            if (!isCompatibleScenario(scenarios[name])) {
                showMessage(`Scenario "${name}" is from an incompatible version (v${scenarios[name].version || 1}) and cannot be loaded. Current version: v${SCENARIO_VERSION}`, 'error');
                return;
            }
            applyScenario(scenarios[name].data);
            closeScenarioModal();
            showMessage(`Scenario "${name}" loaded successfully!`, 'success');
        }
    } catch (error) {
        showMessage(`Failed to load scenario: ${error.message}`, 'error');
    }
}

/**
 * Deletes a specific scenario from appropriate storage location
 * Determines whether scenario is in old or new storage and deletes from correct location
 * Prompts for confirmation before deletion
 * Updates the management view and shows message
 * @param {string} name - Name of the scenario to delete
 */
function deleteScenario(name) {
    if (confirm(`Are you sure you want to delete "${name}"?`)) {
        try {
            const allScenarios = getAllScenarios();
            const scenario = allScenarios[name];
            
            if (scenario.isOldStorage) {
                // Delete from old storage
                const oldScenarios = getOldScenarios();
                delete oldScenarios[name];
                if (Object.keys(oldScenarios).length > 0) {
                    localStorage.setItem(OLD_STORAGE_KEY, JSON.stringify(oldScenarios));
                } else {
                    localStorage.removeItem(OLD_STORAGE_KEY);
                }
            } else {
                // Delete from new storage
                const scenarios = getSavedScenarios();
                delete scenarios[name];
                localStorage.setItem(STORAGE_KEY, JSON.stringify(scenarios));
            }
            
            manageScenarios();
            showMessage(`Scenario "${name}" deleted successfully.`, 'success');
        } catch (error) {
            showMessage(`Failed to delete scenario: ${error.message}`, 'error');
        }
    }
}

/**
 * Closes the scenario management modal dialog
 * No parameters
 */
function closeScenarioModal() {
    document.getElementById('scenarioModal').style.display = 'none';
}

// ============================================================================
// BULK OPERATIONS
// ============================================================================

/**
 * Deletes all scenarios that don't match SCENARIO_VERSION
 * Works across both old and new storage locations
 * Prompts for confirmation showing count and names of scenarios to delete
 * Removes old storage key if all old scenarios are deleted
 * Shows success/error message
 * No parameters
 */
function deleteIncompatibleScenarios() {
    const scenarios = getAllScenarios();
    const incompatibleNames = Object.keys(scenarios).filter(name => 
        !isCompatibleScenario(scenarios[name])
    );
    
    if (incompatibleNames.length === 0) {
        showMessage('No incompatible scenarios found.', 'warning');
        return;
    }
    
    if (confirm(`Delete ${incompatibleNames.length} incompatible scenario(s)?\n\n${incompatibleNames.join('\n')}`)) {
        try {
            const newScenarios = getSavedScenarios();
            const oldScenarios = getOldScenarios();
            
            // Delete from both storage locations
            incompatibleNames.forEach(name => {
                delete newScenarios[name];
                delete oldScenarios[name];
            });
            
            localStorage.setItem(STORAGE_KEY, JSON.stringify(newScenarios));
            
            // Only save old scenarios if there are any left
            if (Object.keys(oldScenarios).length > 0) {
                localStorage.setItem(OLD_STORAGE_KEY, JSON.stringify(oldScenarios));
            } else {
                localStorage.removeItem(OLD_STORAGE_KEY);
            }
            
            manageScenarios();
            showMessage(`${incompatibleNames.length} incompatible scenario(s) deleted.`, 'success');
        } catch (error) {
            showMessage(`Failed to delete scenarios: ${error.message}`, 'error');
        }
    }
}

// ============================================================================
// IMPORT/EXPORT FUNCTIONS
// ============================================================================

/**
 * Exports a single scenario to JSON file
 * Works with scenarios from either storage location
 * Downloads file with scenario name as filename
 * Shows success or error message
 * @param {string} name - Name of the scenario to export
 */
function exportScenario(name) {
    try {
        const scenarios = getAllScenarios();
        const scenario = scenarios[name];
        
        const dataStr = JSON.stringify(scenario, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);
        
        const link = document.createElement('a');
        link.href = url;
        link.download = `${name}.json`;
        link.click();
        
        URL.revokeObjectURL(url);
        showMessage(`Scenario "${name}" exported successfully.`, 'success');
    } catch (error) {
        showMessage(`Failed to export scenario: ${error.message}`, 'error');
    }
}

/**
 * Opens file picker to import scenario from JSON file
 * Warns about version incompatibility if versions don't match
 * Prompts for scenario name (defaults to filename without extension)
 * Adds imported scenario to new storage location
 * Shows success, warning, or error message
 * No parameters
 */
function importScenario() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    
    input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        
        reader.onload = (event) => {
            try {
                const scenario = JSON.parse(event.target.result);
                
                if (scenario.version && scenario.version !== SCENARIO_VERSION) {
                    if (!confirm(`Warning: This scenario is from version ${scenario.version}, current version is ${SCENARIO_VERSION}.\n\nIt may not load correctly. Continue anyway?`)) {
                        showMessage('Import cancelled.', 'warning');
                        return;
                    }
                }
                
                const name = prompt('Enter name for imported scenario:', file.name.replace('.json', ''));
                
                if (name) {
                    const scenarios = getSavedScenarios();
                    scenarios[name] = scenario;
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(scenarios));
                    showMessage(`Scenario "${name}" imported successfully!`, 'success');
                } else {
                    showMessage('Import cancelled.', 'warning');
                }
            } catch (error) {
                showMessage(`Error importing scenario: ${error.message}`, 'error');
            }
        };
        
        reader.onerror = () => {
            showMessage('Failed to read file.', 'error');
        };
        
        reader.readAsText(file);
    };
    
    input.click();
}

/**
 * Exports all scenarios from new storage to single JSON file
 * Downloads with date-stamped filename (format: all-scenarios-YYYY-MM-DD.json)
 * Shows warning if no scenarios exist, otherwise shows success or error message
 * No parameters
 */
function exportAllScenarios() {
    try {
        const scenarios = getSavedScenarios();
        
        if (Object.keys(scenarios).length === 0) {
            showMessage('No scenarios to export.', 'warning');
            return;
        }
        
        const dataStr = JSON.stringify(scenarios, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);
        
        const link = document.createElement('a');
        link.href = url;
        link.download = `all-scenarios-${new Date().toISOString().split('T')[0]}.json`;
        link.click();
        
        URL.revokeObjectURL(url);
        showMessage(`All scenarios exported successfully.`, 'success');
    } catch (error) {
        showMessage(`Failed to export scenarios: ${error.message}`, 'error');
    }
}


// Scan the TAXData for state tax tables and add them to the choice list.
function generateStateOptions() {
    let html = '<option value="NONE">-No State Tax-</option>\n';
    
    const stateKeys = Object.keys(TAXData).filter(key => key.length === 2);
    stateKeys.sort();
    
    stateKeys.forEach(stateCode => {
        const stateData = TAXData[stateCode];
        const isDefault = stateData.Default === true;
        const selectedAttr = isDefault ? ' selected' : '';
        html += `<option value="${stateCode}"${selectedAttr}>${stateData.STATE}</option>\n`;
    });
    
    return html;
}

// 
function generateStratRateOptions() {
    const federal = TAXData.FEDERAL;
    const mfjBrackets = federal.MFJ.brackets;
    const sglBrackets = federal.SGL.brackets;
    
    let html = '';
    
    // Skip the last bracket (Infinity)
    for (let i = 0; i < mfjBrackets.length - 1; i++) {
        const rate = Math.round(mfjBrackets[i].r * 100);
        const mfjLimit = Math.floor(mfjBrackets[i].l / 1000);
        const sglLimit = Math.floor(sglBrackets[i].l / 1000);
        
        // Mark 24% as selected (or choose a different default)
        const selected = (rate === 24) ? ' selected' : '';
        
        html += `<option value="${rate}"${selected}>${rate}%&nbsp;&nbsp;(${mfjLimit}/${sglLimit})k</option>\n`;
    }
    
    return html;
}





// ============================================================================
// INITIALIZATION - Call on page load
// ============================================================================

window.addEventListener('DOMContentLoaded', function() {
	// Generate selection lists from TAXData
	document.getElementById('stratRate').innerHTML = generateStratRateOptions();
	document.getElementById('STATEname').innerHTML = generateStateOptions();	
});



// Auto-run tests when page loads (comment out if you don't want auto-run)
// window.addEventListener('DOMContentLoaded', runTests);
runTests?.();

loadScenarioByName('default');

runSimulation?.();
</script>
</body>
</html>