<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retirement Optimizer 7b</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<!-- <link rel="stylesheet" href="retirementopt_styles.css"> -->
	<link rel="stylesheet" href="retirementopt_styles_responsive.css">	
	<base target="_blank">	
	<script src="retirement_optimizer_tests.js"></script>	
	<script src="retirement_optimizer_text.js"></script>	
	<script src="retirement_optimizer_taxdata.js"></script>	
</head>
<body>

<div class="container">
    <div class="sidebar">
	    <div class="row"><div  id="spending">
            <div><label>After-Tax Spend &nbsp;</label>
            <input type="number" id="spendGoal" value="150000"></div>
            <div><label title="Most retirees follow a spending smile where each year they spend less than the prior year. 98% means you spend 2% less each year. 0 means no change.">Spend Delta %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</label>
            <input type="number" id="spendChange" value="-1" step="0.1" min="-25" max="25" placeholder="0.0"></div>
			</div>
		</div>	
        <div class="input-group">
            <select id="strategy" onchange="toggleStrategyUI()">
                <option value="baseline">Withdraw to meet spend</option>
                <option value="fixed">Reduce IRA in &#120393; Years</option>
                <option value="bracket">Fill Federal Tax Bracket</option>
                <option value="minlimit">ðŸ›‘Lesser of IRMAA or TaxBracket</option>
            </select>
        </div>
        <div id="ui-fixed" class="input-group hidden">
            <label>Target Years (&#120393;)</label>
            <input type="number" id="nYears" value="10">
        </div>
        <div id="ui-bracket" class="input-group hidden">
            <label>Fill Bracket Up To:</label>
            <select id="stratRate">
                <option value="12">12%(100/50)k</option>
                <option value="22">22%(211/105)k</option>
                <option value="24" selected>24%(403/201)k</option>
                <option value="32">32%(512/256)k(</option>
                <option value="35">35%(768/640)k)</option>
            </select>
        </div>
	
        <div class="row">
			<label title="Draw down IRA to this amount or less.">IRA Goal</label>
            <input type="number" id="iraBaseGoal" value="350000" width="50%"><BR>
			<label>
			  <input type="checkbox" id="maxConversion" name="maxConversion" checked>
			  Max Conversion
			</label>
			
		</div>	
	
		
        <h3>1. Profile & Ages</h3>
        <div class="row">
            <div><label>Your Birth Year</label><input type="number" id="birthyear1" value="1960"></div>
            <div><label>Life Expectancy</label><input type="number" id="die1" value="88"></div>
        </div>
        <div class="row">
            <div><label>Spouse Birth Year</B></label><input type="number" id="birthyear2" value="1952"></div>
            <div><label>Spouse Expectancy</label><input type="number" id="die2" value="98"></div>
        </div>

        <h3>2. Assets (Current)</h3>
        <div class="row">
            <div><label>Your IRA</label>  <input type="number" id="ira1" value="1000000"></div>
            <div><label>Spouse IRA</label><input type="number" id="ira2"  value="400000"></div>
        </div>
        <div class="row">
            <div><label>Brokerage</label><input type="number" id="brokerage" value="100000"></div>
            <div><label>Brokerage Basis</label><input type="number" id="basis" value="100000"></div>
        </div>
        <div class="row">
            <div><label>Roth IRA</label><input type="number" id="roth" value="50000"></div>
            <div><label>Cash Balance</label><input type="number" id="cash" value="50000"></div>
        </div>

        <h3>3. Income (annual)</h3>
        <div class="row">
            <div><label>Social Security Amt</label><input type="number" id="ss1" value="48000"></div>
            <div><label>Start Age</label><input type="number" id="ss1Age" value="70"></div>
        </div>
        <div class="row">
            <div><label>Spouse SS Amt</label><input type="number" id="ss2" value="24000"></div>
            <div><label>Spouse Start Age</label><input type="number" id="ss2Age" value="70"></div><BR>
        </div>
        <div class="row">
            <div><label>Your Pension</label><input type="number" id="pensionAnnual" value="15000"></div>
            <div><label>Survivorship %</label><input type="number" id="survivorPct" value="75"></div>
        </div>


        <h3>4. Assumptions</h3>
        <div class="row">
            <div><label><A HREF="https://www.investopedia.com/inflation-rate-by-year-7253832" target="_blank">Inflation</A> (3?)%</label><input type="number" id="inflation" value="3.0" step="0.01" min="0" placeholder="0.00"></div>
            <div><label><A HREF="https://www.bls.gov/regions/mid-atlantic/data/consumerpriceindexhistorical_us_table.htm" target="_blank">CPI</A>/<A HREF="https://www.fool.com/retirement/social-security/cola-history/" target="_blank">COLA</A> (2.8?)%</label><input type="number" id="cpi" value="2.8" step="0.01" min="0" placeholder="0.00"></div>
        </div>
        <div class="row">
            <div><label title="Your asset mix will dictate what growth rate to expect. In a brokerage, your basis doesn't grow at the rate the account does.">Growth (6)%</label><input type="number" id="growth" value="6.0"></div>
            <div><label title="What does your HYSA and/or Mutual fund produce annually?">Cash Interest (2.5)%?</label><input type="number" id="cashYield" value="3.0" step="0.01" min="0" placeholder="0.00"></div>
        </div>
        <div class="row">
			<div><label title="This is the rate that your asset mix emits dividends.">Dividend Rate (0.5)?</label><BR><input type="number" id="dividendRate" value="0.5" step="0.01" min="0" placeholder="0.00">%</div>
			<div><label title="Pick the state that you live in or plan to live in through retirement"><STRONG>State</STRONG> Taxation</label><BR>
            <select id="STATEname"">
                <option   value="NONE">-No State Tax-</option>
                <option   value="CA" selected>California</option>
                <option   value="CT">Connecticut</option>
                <option   value="IL">Illinois</option>
                <option   value="MD">Maryland</option>
                <option   value="MI">Michigan</option>
                <option   value="NY">New York</option>
                <option   value="NC">North Carolina</option>
                <option   value="OR">Oregon</option>
                <option   value="PA">Pennsylvania</option>
                <option   value="VA">Virginia</option>
				<option   value="DC">Washington,DC</option>
            </select>
			</div>			
		</div>
        <div class="row">
			<div><label title="Social security is on track to exhaust the trust fund in 2033. You can change what year this occurs in.">Social Security Fail</label> <input type="number" id="ssFailYear" value="2033"></div>
            <div><label title="If you think social security will not fall to a 77.3% payout in 2033, set this number to 100">SS Net Payout%</label><input type="number" id="ssFailPct" value="77.3"></div>
        </div>

    </div>

    <div class="main">
			<div class="header-drawers">
			<details class="top-drawer"><summary>Change Log</summary><div><br>
				<div class="log-entry">
				</div>
				<ul>
				<li><b>7b</b> More state rates. Fixed most calculations. Minor UI changes. Changed the defaults to something "more common" - . See the <A HREF="https://nightskyguy.github.io/retirement_assets/">README.md</A>. </li>					
				<li>7a Now has various state rates. Fixed most calculations. See <A HREF="https://nightskyguy.github.io/retirement_assets/">README.md</A> for details. </li>	
				
				<li>6v Implemented Save/Load/Export/Delete Scenarios.</li>	
				<li>6u Implemented SS Fail. More UI fixes. Moved all strategy items to the top.</li>	
				<li>6t Solved a math issue causing NaN to occur. Cleaned up the visuals.</li>				
				<li>6s Some more fancy highlighting of the tables. Fixed broken strategy changer. Tests moved into separate file, too.</li>				
				<li>6r Moved the heavy text (top drawers) into a separate file.</li>
				<li>6q Beautifications and hover notes. More self tests with an indicator on screen if they fail. Started the Social Security "meltdown" implementation. Added (empty) Insights tab.
				</li><li>6p Corrected instructions for Single filer usage. Fixed error in brokerage tracking. Added brokerage dividend rate. Dividends automatically accrue to Cash.
				</li><li>6n Calculation fixes. WARNING: detailed calculations not done - but current calcs are accurate.
				</li><li>6m More self tests, some rework.
				</li><li>6k Reworked tax brackets for sanity ease of update. Added more instructions. 
				</li><li>6j Move style sheet out for readability.
				</li><li>6i Remove the Recalculate and Optimize buttons. Use the similarly named tabs as the buttons. 
				</li><li>5hp Integrated Federal SS "Tax Torpedo" logic, California HSA add-backs, and IRMAA cliff surcharges. This logic is present, but not yet being used.  The older logic is "close".
				</li><li>5h Added change log and instructions
				</li><li>4g Do rate limit lookups based on inflation. Add suggested values.
				</li><li>4f Use cpi% to adjust taxation (brackets)
				</li><li>4e Use calculated birthyear for correct RMDs
				</li>
				</ul>
				</div>
			</details>

			<details class="top-drawer">
				<summary>How to Use</summary><div class="drawer-content" id="drawer-howto"></div>
			</details>
			<details class="top-drawer"><summary>Planned <strong id="testsFailed">ðŸŸ¢</strong></summary><div class="drawer-content" id="drawer-planned"></div>
			</details>
			<details class="top-drawer"><summary>Background</summary><div class=drawer-content" id="drawer-background"></div>
			</details>
		</div>	
        <div class="top-bar">
            <div id="summary-stats" style="display:flex; gap:30px;">
				<div id="stat-success">  </div>
				<div><small>Years of Life</small><br><strong id="stat-years">0</strong></div>
				<div><small>Funded Years</small><br><strong id="stat-yearsfunded">0</strong></div>
                <div><small>LIFETIME TAX RATE</small><br><strong id="stat-rate">0%</strong></div>
                <div><small>TOTAL TAX</small><br><strong id="stat-tax">$0</strong></div>
                <div><small>TOTAL Spendable</small><br><strong id="stat-spend">$0</strong></div>
                <div><small>FINAL WEALTH</small><br><strong id="stat-nw">$0</strong></div>
            </div>
            </div>

        <div class="tabs">
            <button id="btn-tbl" class="tab-btn active" onclick="{runSimulation(); showTab('tab-tbl')}">Annual Details</button>
            <button id="btn-cht" class="tab-btn" onclick="{runSimulation(); showTab('tab-chart')}">Chart</button>
            <button id="btn-opt" class="tab-btn" onclick="{showTab('tab-insight')}">Insights</button>
            <button id="btn-opt" class="tab-btn" onclick="{runOptimizer(); showTab('tab-opt')}">Optimizer</button>
		    <button id="btn-fileio" class="tab-btn" onclick="{showTab('tab-fileio')}">Import/Export</button>


        </div>
		<div id="tab-insight" class="card hidden">
			ðŸ›‘ Some pithy insights will appear here. Right now it's not implemented.
			<h4>Where is the Code</h4>
			This might be useful to know: you can run this locally (download the *.html and *.js and *.css files from github) 
			<A HREF="https://github.com/nightskyguy/retirement_assets">https://github.com/nightskyguy/retirement_assets</a>.
			<p>And you can also take a look at the source, make comments, or even open a pull request to propose changes. Just follow the link above.

			You can also directly <strong>run</strong> the code from github: <A HREF="https://nightskyguy.github.io/retirement_assets/retirement_optimizer.html">nightskyguy.github.io/retirement_assets/retirement_optimizer.html</a>
			
			<p>If you're wondering whether you're being tracked, the answer is no. There is no logic 
			(currently) to do any kind of tracking or telemetry. You can read the code if you're skeptical.
			And by the way, you SHOULD be skeptical.

			<table id="insights-table">
				<thead>
					<tr id="groupRow"></tr>
					<tr id="headerRow"></tr>
				</thead>
				<tbody id="tableBody"></tbody>
			</table>
		</div>
		<div id="tab-fileio" class="card hidden">
			<div class="scenario-controls">
				<div class="scenario-row">
					<input type="text" id="scenarioName" placeholder="Scenario name (optional)" style="flex: 1; margin-right: 10px;">
					<button onclick="saveScenario()">Save Scenario</button>
					<button onclick="manageScenarios()">Manage Scenarios (Load, Delete, Export)</button>
					<button onclick="importScenario()">Import</button>
				</div>
				<div id="scenarioMessage" class="scenario-message"></div>
				<div id="scenarioList" style="display: none; margin-top: 10px;">
					<!-- Scenario list will be populated here -->
				</div>
			</div>

			<!-- Modal for managing scenarios -->
			<div id="scenarioModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
				<div style="background: white; margin: 50px auto; padding: 20px; max-width: 600px; border-radius: 8px; max-height: 80vh; overflow-y: auto;">
					<h3>Saved Scenarios</h3>
					<div id="scenarioListContent"></div>
					<button onclick="closeScenarioModal()" style="margin-top: 10px;">Close</button>
				</div>
			</div>	
		</div>

		<div id="tab-tbl" class="card table-wrap">
			<table id="main-table">
				<thead>
					<tr id="groupRow"></tr>
					<tr id="headerRow"></tr>
				</thead>
				<tbody id="tableBody"></tbody>
			</table>
		</div>

        <div id="tab-chart" class="card hidden">
            <canvas id="chartAssets" style="max-height:350px;"></canvas>
            <hr>
            <canvas id="chartTaxSpend" style="max-height:350px;"></canvas>
        </div>

        <div id="tab-opt" class="card hidden table-wrap">
            <table id="opt-table">
                <thead>
                    <tr>
                        <th>Strategy</th>
                        <th>Total Lifetime Tax</th>
                        <th>Final Wealth</th>
                        <th>Effective Tax Rate</th>
                        <th>Years Funded</th>
						<th>Success/Fail</th>
						<th>Years Tested</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // document.getElementById('drawer-changelog').innerHTML = drawerContent.changelog;
    document.getElementById('drawer-howto').innerHTML = drawerContent.howToUse;
    document.getElementById('drawer-planned').innerHTML = drawerContent.planned;
    document.getElementById('drawer-background').innerHTML = drawerContent.background;
});

// CONFIGURATION CONSTANTS
// ============================================================================

// Version constant - increment this when data structure changes
const SCENARIO_VERSION = 3;

// New storage key for current version scenarios
const STORAGE_KEY = 'SLCRetireOptimizeScenario';

// Old storage key from previous version
const OLD_STORAGE_KEY = 'retirementScenarios';



/** TAX CONSTANTS **/
// Find these in retirement_optimizer_taxdata.js

// The default state to use for STATE calculations.
let STATEname = 'CA'

function inspectForErrors(inputs) {
	for (const [name, value] of Object.entries(inputs)) {
		if (value === undefined) {
			console.error(`âŒ ${name} is undefined`);
			debugger;
		} else 
		if (isNaN(value)) {
			console.error(`âŒ ${name} is NaN`);
			debugger;
		} else 
		if (!isFinite(value) && value !== 0) {
			console.error(`âŒ ${name} is Infinity`);
			debugger;
		}
	}
}

function getRMDPercentage(age, birthYear) {
const startAge = (birthYear >= 1960) ? 75 : 73;
    if (age < startAge) return 0;
    if (age > 120) return 1/RMD_TABLE[120];
    return 1/(RMD_TABLE[age]);
}

function getRateBracket(entity, status) {
    let brks = TAXData?.[entity]?.[status]?.brackets;

    if (!brks) {
        console.error(`Invalid tax data: entity="${entity}", status="${status}"`);
        return null
	};
		
	return brks
}

// Calculate the withdrawal rate to reduce an account from currentIRA to targetIRA
function calculateAmortizedWithdrawal(currentIRA, targetIRA, years, growthRate) {
    // Amount that needs to be withdrawn
    const excessAmount = currentIRA - targetIRA;
    
    // Grow the target to its future value
    const targetFV = targetIRA * Math.pow(1 + growthRate, years);
    
    // Calculate required annual withdrawal (amortization of excess)
    const r = growthRate;
    const n = years;
    
    if (r === 0) {
        return excessAmount / n;
    }
    
    const withdrawal = excessAmount * (r * Math.pow(1 + r, n)) / (Math.pow(1 + r, n) - 1);
    
    return withdrawal;
}


// Find the top amount in the provided brackets. If the bracket isn't found, it finds 
// the limit in the next lower bracket.  This doesn't check to be sure any values are reasonable.

function findLimitByRate( entity, status, tgtrate, inflation=1) {
    let brks = getRateBracket(entity, status)

    let limit = 0;
	let rate = 0;
	
    for (let b of brks) {
        if (b.r <= tgtrate ) {
			limit = b.l * inflation;
			rate = b.r;
        } else break;
    }
	return { limit, rate: rate }
}


// We want to find the limit of the next bracket HIGHER than the amount given (that is the upper limit).
// For example if the limits are 10, 100, 1000 and the amount is 150 - we want the 1000 (less 1).
// If amount is 99, we want 100.
function findUpperLimitByAmount( entity, status, amount, inflation=1) {
    let limit = 0;
	let rate = 0;
    let brks = getRateBracket(entity, status)
	
    for (let b of brks) {
        if (b.l * inflation <= amount ) {
			rate = b.r;
        } else {
			limit = b.l * inflation - 1;
			break;
		}
    }
	return { limit, rate: rate }
}

///

function calculateBrokerageWithdrawal(withdrawal, brokerageBalance, brokerageBasis) {
    // Can't withdraw more than available balance
    const actualWithdrawal = Math.min(withdrawal, brokerageBalance);
    
    // Calculate proportion of account being withdrawn
    const proportion = brokerageBalance > 0 ? actualWithdrawal / brokerageBalance : 0;
    
    // Calculate basis reduction (proportional to withdrawal)
    const basisChange = brokerageBasis * proportion;
    
    // Amount subject to capital gains = withdrawal minus the basis portion
    const capitalGains = actualWithdrawal - basisChange;
    
    return {
        withdrawn: actualWithdrawal,           // Total amount withdrawn
        capitalGains: capitalGains,            // Amount subject to capital gains tax
        basisChange: basisChange               // Change in basis (positive = reduction)
    };
}

/**
 * Calculates withdrawal amounts from multiple accounts based on strategy, accounting for taxes
 * @param {Object} balances - Account balances
 * @param {number} balances.IRA - IRA balance
 * @param {number} balances.Brokerage - Brokerage account balance
 * @param {number} balances.BrokerageBasis - Brokerage cost basis
 * @param {number} balances.Cash - Cash balance
 * @param {number} balances.Roth - Roth IRA balance
 * @param {number} gapAmount - Total NET amount needed (after taxes)
 * @param {Object} withdrawStrategy - Withdrawal strategy definition
 * @param {Array<string>} withdrawStrategy.order - Order of ALL accounts (including zero-weight)
 * @param {Array<number>} withdrawStrategy.weight - Relative weights for each account in order if null, weights are based on account balances.
 * @param {Array<number>} withdrawStrategy.taxrate - Tax rates for each account (0.0 to 1.0)
 * @returns {Object} Withdrawal amounts (gross), taxes paid, net amounts, and remaining shortfall
 */

function calculateWithdrawals(balances, gapAmount, withdrawStrategy) {
    // Initialize result structure
    const result = {
        totalTax: 0,
        netAmount: 0,
        shortfall: 0
    };
    
    // Check edge cases
    let errors = [];
    
    gapAmount == null || (gapAmount <= 0) && errors.push("gapAmount is null or <= 0");
    (withdrawStrategy == null || Object.keys(withdrawStrategy).length === 0) && errors.push("withdrawStrategy is null or empty");
    (balances == null || Object.keys(balances).length === 0) && errors.push("balances is null or empty");
    (withdrawStrategy?.order == null || Object.keys(withdrawStrategy.order).length === 0) && errors.push("withdrawal.order is null or empty");
    
    if (errors.length > 0) {
        result.errors = errors;
        return result;
    }
    
    const order = withdrawStrategy.order;
    const taxrates = withdrawStrategy.taxrate;
    const originalGapAmount = gapAmount;
    
    const {BrokerageBasis, ...rest} = balances;
    let totalFunds = Object.values(rest).reduce((sum, v) => sum + v, 0);
    
    let normalizedWeight;
	
	// Normalize the weights (if they exist - or create weights from balances if not.
	if (withdrawStrategy.weight?.length > 0) {
	  const sum = withdrawStrategy.weight.reduce((a, b) => a + b, 0);
	  normalizedWeight = withdrawStrategy.weight.map(w => w / sum);
	} else {
	  const orderBalances = withdrawStrategy.order.map(acct => balances[acct]);
	  const sum = orderBalances.reduce((a, b) => a + b, 0);
	  normalizedWeight = orderBalances.map(bal => bal / sum);
	}	// withdrawStrategy.weight exists or not.	
	
    
    let netRemaining = gapAmount;
    
    // Phase 1: Process weighted accounts
    const netTargets = {};
    
    for (let i = 0; i < order.length; i++) {
        const account = order[i];
        const weight = normalizedWeight[i];
        netTargets[account] = weight > 0 ? (originalGapAmount * weight) : 0;
    }
    
    // Helper function to calculate effective tax rate for an account
    function getEffectiveTaxRate(account, grossWithdrawal) {
        if (account !== 'Brokerage') {
            // For non-brokerage accounts, use the full tax rate
            return taxrates[order.indexOf(account)] ?? 0;
        }
        
        // For brokerage, only tax the capital gains portion
        const brokerageInfo = calculateBrokerageWithdrawal(
            grossWithdrawal,
            balances.Brokerage,
            balances.BrokerageBasis
        );
        
        // Effective tax rate = (capital gains / total withdrawal) * tax rate
        const taxRate = taxrates[order.indexOf(account)] ?? 0;
        return grossWithdrawal > 0 ? (brokerageInfo.capitalGains / grossWithdrawal) * taxRate : 0;
    }
    
    // Helper function to perform a withdrawal from an account
    function performWithdrawal(account, grossWithdrawal, accountIndex) {
        if (grossWithdrawal <= 0.01) return { netWithdrawal: 0, tax: 0 };
        
        const taxRate = taxrates[accountIndex] ?? 0;
        let netWithdrawal, tax;
        
        if (account === 'Brokerage') {
            // Use the brokerage-specific calculation
            const brokerageInfo = calculateBrokerageWithdrawal(
                grossWithdrawal,
                balances.Brokerage,
                balances.BrokerageBasis
            );
            
            // Tax only applies to capital gains
            tax = brokerageInfo.capitalGains * taxRate;
            netWithdrawal = grossWithdrawal - tax;
            
            // Track basis change
            if (!result.BrokerageBasis) result.BrokerageBasis = 0;
            result.BrokerageBasis += brokerageInfo.basisChange; 
            
        } else {
            // For other accounts, simple calculation
            tax = grossWithdrawal * taxRate;
            netWithdrawal = grossWithdrawal - tax;
        }
        
        // Update result
        if (!result[account]) result[account] = 0;
        if (!result[account + 'Tax']) result[account + 'Tax'] = 0;
        
        result[account] += grossWithdrawal;
        result[account + 'Tax'] += tax;
        
        return { netWithdrawal, tax };
    }
    
    // Phase 1: Withdraw from weighted accounts up to their targets
    for (let i = 0; i < order.length; i++) {
        if (netRemaining <= 0.01) break;
        
        const account = order[i];
        const netTarget = netTargets[account];
        
        if (netTarget <= 0) continue; // Skip zero-weight accounts
        
        const available = balances[account] ?? 0;
        if (available <= 0.01) continue;
        
        // We need to solve for grossWithdrawal iteratively for brokerage
        // For simplicity, we'll use an approximation approach
        let grossWithdrawal;
        
        if (account === 'Brokerage') {
            // Iterative approach to find the right gross withdrawal
            // Start with an estimate
            const taxRate = taxrates[i] ?? 0;
            let estimate = netTarget / (1 - taxRate); // Initial estimate
            
            // Refine estimate (up to 3 iterations should be enough)
            for (let iter = 0; iter < 3; iter++) {
                const testInfo = calculateBrokerageWithdrawal(estimate, balances.Brokerage, balances.BrokerageBasis);
                const testTax = testInfo.capitalGains * taxRate;
                const testNet = estimate - testTax;
                
                if (Math.abs(testNet - netTarget) < 0.01) break;
                
                // Adjust estimate
                const correction = netTarget - testNet;
                estimate += correction / (1 - taxRate * (testInfo.capitalGains / estimate));
            }
            
            grossWithdrawal = Math.min(estimate, available, netTarget / (1 - taxRate) * 2); // Safety cap
        } else {
            const taxRate = taxrates[i] ?? 0;
            const grossTarget = netTarget / (1 - taxRate);
            const grossNeeded = netRemaining / (1 - taxRate);
            grossWithdrawal = Math.min(grossTarget, available, grossNeeded);
        }
        
        grossWithdrawal = Math.min(grossWithdrawal, available);
		inspectForErrors({available: available, grossWithdrawal: grossWithdrawal})
        
        const { netWithdrawal, tax } = performWithdrawal(account, grossWithdrawal, i);
        netRemaining -= netWithdrawal;
    }
    
    // Phase 2: If gap not satisfied, take from remaining balances in order
    if (netRemaining > 0.01) {
        for (let i = 0; i < order.length; i++) {
            if (netRemaining <= 0.01) break;
            
            const account = order[i];
            const alreadyWithdrawn = result[account] ?? 0;
            const available = (balances[account] ?? 0) - alreadyWithdrawn;
            
            if (available <= 0.01) continue;
            
            // Calculate how much gross we need to get the net we need
            let grossWithdrawal;
            
            if (account === 'Brokerage') {
                // Iterative approach for brokerage
                const taxRate = taxrates[i];
                let estimate = netRemaining / (1 - taxRate);
                
                for (let iter = 0; iter < 3; iter++) {
                    const remainingBalance = balances.Brokerage - alreadyWithdrawn;
                    const remainingBasis = balances.BrokerageBasis - (result.BrokerageBasis ?? 0);
                    
                    const testInfo = calculateBrokerageWithdrawal(estimate, remainingBalance, remainingBasis);
                    const testTax = testInfo.capitalGains * taxRate;
                    const testNet = estimate - testTax;
                    
                    if (Math.abs(testNet - netRemaining) < 0.01) break;
                    
                    const correction = netRemaining - testNet;
                    estimate += correction / (1 - taxRate * (testInfo.capitalGains / estimate));
                }
                
                grossWithdrawal = Math.min(estimate, available);
            } else {
                const taxRate = taxrates[i];
                const grossNeeded = netRemaining / (1 - taxRate);
                grossWithdrawal = Math.min(available, grossNeeded);
            }
            
            const { netWithdrawal, tax } = performWithdrawal(account, grossWithdrawal, i);
            netRemaining -= netWithdrawal;
        }
    }
    
    // Calculate totals
    let totalWithdrawals = Object.entries(result)
        .filter(([k]) => !k.endsWith('Tax') && !k.endsWith('Basis') && !k.includes('total') && k !== 'shortfall' && k !== 'netAmount' && k !== 'errors')
        .reduce((sum, [, v]) => sum + v, 0);
    
    result.totalTax = Object.entries(result)
        .filter(([k]) => k.endsWith('Tax'))
        .reduce((sum, [, v]) => sum + v, 0);
    
    result.netAmount = totalWithdrawals - result.totalTax;
    result.shortfall = Math.max(0, gapAmount - result.netAmount);
    
    // Round all results to 3 decimals
    Object.keys(result).forEach(k => {
        if (typeof result[k] === 'number') {
            result[k] = +result[k].toFixed(3);
        }
    });
    
    return result;
}


// Apply withdrawals  to the balances MUTATES balances!
function applyWithdrawals(balances, withdrawals) {
    for (const key in withdrawals) {
        if (key in balances) {
            balances[key] = Math.max(0, balances[key] - withdrawals[key]);
        }
    }
    return balances;  // Optional - for chaining/convenience
}

function accumulateWithdrawals(withdrawalsArray) {
    const totals = {};
    
    for (const withdrawals of withdrawalsArray) {
        for (const key in withdrawals) {
            if (key in totals) {
                totals[key] += withdrawals[key];
            } else {
                totals[key] = withdrawals[key];
            }
        }
    }
    
    return totals;
}


function applyGrowth(balances, growthRates) {
	const gains = {}
	let gain = 0;
    for (const key in balances) {
        if (key in growthRates) {
            // Apply growth: balance * (1 + rate)
			gain = balances[key] * growthRates[key]
			gains[key] = gain;
            balances[key] = Math.max(0, balances[key] + gain);
        }
        // If no matching rate, balance remains unchanged
    }
    return gains;  // Return the amounts gained/lost
}


function sumAccounts(obj, keys = ['IRA', 'IRA1', 'IRA2', 'Roth', 'Brokerage', 'Cash']) {
    return keys.reduce((sum, key) => sum + (obj[key] ?? 0), 0);
}

/////////////////////////////


let simulationCount = 0;
/** SIMULATION ENGINE **/
function simulate(inputs) {
    let balance = {
        IRA1: inputs.IRA1, IRA2: inputs.IRA2, Roth: inputs.Roth,
        Brokerage: inputs.Brokerage, BrokerageBasis: inputs.BrokerageBasis, Cash: inputs.Cash,
        magiHistory: []
    };
    simulationCount += 1;
	STATEname = inputs.STATEname;
    let log = [];
	//!!!TODO Remove hardcoded start year!
    let startYear = 2026;
	let birthyear1 = inputs.birthyear1;
	let birthyear2 = inputs.birthyear2;

    let maxYears = Math.max(inputs.birthyear1 + inputs.die1, inputs.birthyear1 + inputs.die2) - startYear + 1;
    let totals = { tax: 0, gross: 0, spend: 0, yearsfunded: 0, success: true, yearstested: 0, failedInYear: [] };

	let cpiRate = 1
	let inflation = 1
	let fixedWithdrawal = calculateAmortizedWithdrawal(balance.IRA1 + balance.IRA2, inputs.iraBaseGoal, inputs.nYears,inputs.growth)
	let currentTaxableGuess = 0;
	let spendDelta = 1
	let spendGoal = inputs.spendGoal;
	let cumulativeTaxes = 0;
	let nominalTaxRate = 0.20; // Just a guess.
	let marginalTaxRate = 0.33; // Just a guess.
	let capitalGainsRate = 0.15; // A guess.
	let tax;
	
	
	
	/**************************************
	 * PROCESS:
		Determine tax status 
		Determine SS & pension income.
	    Determine targetIncome based on strategy:
			For fixed, use larger of amortization rate or spendGoal
				WithdrawalStrategy = [IRA:100, Cash:0, Brok:0]
			For baseline, use SpendGoal 
				WithdrawalStrategy = [IRA, Brok, Cash, Roth] by balance percent.
			For delay, use SpendGoal
				WithdrawalStrategy = [Brok: 100, IRA: 0, Cash: 0
			For bracket, use larger of bracket limit or spendGoal
				WithdrawalStrategy = [IRA:*, Brok:*, Cash:0]
					
	 *
	 *************************************/

    for (let y = 0; y < maxYears; y++) {
		spendGoal = spendGoal * spendDelta * (1+inputs.inflation);
		
		cpiRate = (1 + inputs.cpi) * cpiRate
		inflation = (1 + inputs.inflation) * inflation
		spendDelta = inputs.spendChange;
		
		let withdrawals = { IRA: 0, IRA1: 0, IRA2: 0, Roth: 0, Brokerage: 0, BrokerageBasis: 0, Cash: 0};
		let withdrawals_round2 = withdrawals;
		let netWithdrawals = withdrawals;
		
		let basisWithdrawn = 0;
		let wdIRA = 0;
		let depRoth = 0;
		let depBrokerage = 0;
		let depCash = 0;


        let age1 = startYear - birthyear1 + y;
        let age2 = startYear - birthyear2 + y;
        let alive1 = age1 <= inputs.die1;
        let alive2 = age2 <= inputs.die2;
        if (!alive1 && !alive2) break;

		totals.yearstested += 1;

        let status = (alive1 && alive2) ? 'MFJ' : 'SGL';
		// IRMAA is already known since it is based on income from 2 years ago.
        let irmaa = calcIRMAA(balance.magiHistory[balance.magiHistory.length-2], status, cpiRate);
		
		// Calculate the bracket limits based on: stated limit.
		let tgtBracketLimit = findLimitByRate('FEDERAL',status,inputs.stratRate)
		
		// Find federal & state rates and limits by spending goal:
		let goalFedBracketLimit = findUpperLimitByAmount('FEDERAL', status, spendGoal , cpiRate)
		let goalStateBracketLimit = findUpperLimitByAmount(STATEname, status, spendGoal, cpiRate)
		let goalLimit = Math.min(goalFedBracketLimit.limit, goalStateBracketLimit.limit)
		let irmaaBracket = findUpperLimitByAmount('IRMAA', status, goalLimit, cpiRate)
		let irmaLimit = Math.min(goalLimit, irmaaBracket.limit);
		let totalIncome, netIncome = 0;
		let capitalGains = 0;		
	
		//!!! TODO: if strategy is "bracket" but spendGoal is > bracket limit
		//		    we likely have a problem unless non-taxable accounts can backfill.

        // 1. Inherit IRA
        if (!alive1 && balance.IRA1 > 0) { balance.IRA2 += balance.IRA1; balance.IRA1 = 0; }
        if (!alive2 && balance.IRA2 > 0) { balance.IRA1 += balance.IRA2; balance.IRA2 = 0; }


        // 2. Base Income
		let ssReduction = (inputs.ssFailYear > 2000 && startYear + y >= inputs.ssFailYear) ? inputs.ssFailPct : 1;
        let s1 = (alive1 && age1 >= inputs.ss1Age) ? inputs.ss1 * cpiRate * ssReduction : 0;
        let s2 = (alive2 && age2 >= inputs.ss2Age) ? inputs.ss2 * cpiRate * ssReduction : 0;
        let pension = inputs.pensionAnnual;
		
		// One is deceased (if both decease, it won't get here)
        if (!alive1 || !alive2) {
            // Survivor Logic: Max of SS + Survivorship % of Pension
            s1 = Math.max(s1, s2);
            s2 = 0;
            if (!alive1) { pension = pension * (inputs.survivorPct/100) }
        }
        let fixedInc = s1 + s2;					// Social Security
		let taxableInc = pension;				// Pensions, W2, RMDs, wdIRA, wdBrokerage
		let taxableInterest = balance.Cash * inputs.cashYield
		let taxableDividends = balance.Brokerage * inputs.dividendRate
		

        // 3. RMDs
        let rmd1 = alive1 ? balance.IRA1 * getRMDPercentage(age1, birthyear1) || 0 : 0;
        let rmd2 = alive2 ? balance.IRA2 * getRMDPercentage(age2, birthyear2) || 0 : 0;
		
		// Immediately remove RMDs from the respective IRAs because they MUST be taken first.
		// TODO: Allow RMDs to go to QCDs one day!
		balance.IRA1 = Math.max(0, balance.IRA1 - rmd1);
		balance.IRA2 = Math.max(0, balance.IRA2 - rmd2);
		let curIRA = Math.max(0, balance.IRA1 + balance.IRA2 - inputs.iraBaseGoal);


		
        let totalRMD = rmd1 + rmd2;
		taxableInc += totalRMD

        // 4. Determine Target Spending amount based on Strategy
        let targetSpend = Math.min(spendGoal, goalLimit);
        let additionalSpendNeeded = Math.max(0, targetSpend - fixedInc - taxableInc + irmaa);

		//!!! Find the income federal limit. TODO: use that limit, to refine down to the next lower IRMAA limit and next lower State Limit.
		let marginalFedTaxRate = goalFedBracketLimit.rate
		let marginalStateTaxRate = goalStateBracketLimit.rate
		
		//	calculateProgressive('FEDERAL', status, amount, inflation=1, ratecreep=1)

		let nominalFedTaxRateAtLimit = 0.14;
		let nominalStateTaxAtLimit = 0.07
		let withdrawStrategy = {order: [], weight: [], taxrate: []};
		
		let curBalances = {IRA: balance.IRA1 + balance.IRA2, Brokerage: balance.Brokerage, BrokerageBasis: balance.BrokerageBasis, Roth: balance.Roth, Cash: balance.Cash, IRA1: balance.IRA1, IRA2: balance.IRA2};
			

        if (inputs.strategy === 'fixed') {
			// In this strategy, we confine withdrawals to the IRA for the first round. 
			// We don't care about the tax implications.
			
            let remYears = Math.max(1, inputs.nYears - y);
			let amortized = Math.max(0, fixedWithdrawal - totalRMD);

			// Withdraw the fixed amount left after RMDs, or whatever is left in IRAs after leaving room
			withdrawals = { IRA: Math.max(0,Math.min(curIRA, amortized)) }
			
        } else if (inputs.strategy === 'bracket' || inputs.strategy === 'minlimit') {
			//!!! This code has flaws.  Withdraws too much.
			let fedLimit = findLimitByRate('FEDERAL', status, inputs.stratRate, cpiRate);
			let limit = fedLimit.limit;
			let fedTaxAtLimit = calculateProgressive('FEDERAL', status, limit, inflation)
			nominalFedTaxRateAtLimit = fedTaxAtLimit.cumulative / limit
			marginalFedTaxRate = fedLimit.rate;	

			//!!!TODO Find the state rate and limit that corresponds to the limit (fedLimit.fedLimit)
			//!!!TODO Find the IRMAA limit that corresponds to the fedLimit.fedLimit
			let stLimit = findUpperLimitByAmount(STATEname, status, fedLimit.limit, cpiRate);
			marginalStateTaxRate = stLimit.rate;
			stateLimit = stLimit.limit;
			nominalStateTaxAtLimit = calculateProgressive(STATEname, status, limit, inflation).cumulative / limit
			
			// pick whatever is smaller (state or Federal limit for the amount desired)
			limit = Math.min(stateLimit, limit)
			
			if (inputs.strategy === 'minlimit') {
				limit = Math.min(limit, irmaLimit)
			}
			
            currentTaxableGuess = limit - fixedInc - taxableInc - totalRMD;
			wdIRA = Math.min(Math.max(0, currentTaxableGuess), balance.IRA1 + balance.IRA2);
			
        } else {
			/*********************/
			/* BASELINE Strategy */
			/*********************/
	        // Withdraw enough proportionately to get to spendGoal - including taxes.
			withdrawStrategy.order = ['IRA', 'Brokerage', 'Cash']
			withdrawStrategy.taxrate = [ nominalTaxRate, capitalGainsRate + nominalStateTaxAtLimit, 0, 0]
			withdrawals = calculateWithdrawals(curBalances, additionalSpendNeeded, withdrawStrategy)
	
		}
		
		
		applyWithdrawals( curBalances, withdrawals)
		inspectForErrors( curBalances, withdrawals)
        
		netWithdrawals = accumulateWithdrawals( [netWithdrawals, withdrawals])
		capitalGains = netWithdrawals.BrokerageBasis  ?? 0

        // 5. Tax Calc (Including IRMAA lag)
		//!!! TODO: May be premature. We may need more $ to meet spend goal.  We may have exhausted the IRAs.
		
		inspectForErrors({fixedInc: fixedInc, wdIRA: wdIRA, totalRMD: totalRMD, taxableInterest: taxableInterest, capitalGains: capitalGains, taxableDividends: taxableDividends, age1: age1, age2: age2, cpiRate: cpiRate})
			

		// function calculateTax(fixed, netWithdrawals.IRA`, gains, status, a1, a2, inflation=1, ratecreep=1) 
        tax = calculateTax(fixedInc, netWithdrawals.IRA + totalRMD + taxableInterest, capitalGains + taxableDividends, status, age1, age2, cpiRate);
		inspectForErrors(tax)  // See if any numbers look fishy.
		//!!! Assume MAGI for prior to years is the same as this year. Should allow this to be entered
		marginalFedTaxRate = tax.fedRate;
		marginalStateTaxRate= tax.stateRate;
		
		let magiHistoryLength = balance.magiHistory.length
		if (magiHistoryLength < 1) {
			balance.magiHistory.push(tax.magi);
			balance.magiHistory.push(tax.magi);
		}

        let totalTax = tax.total + irmaa;
		cumulativeTaxes += totalTax;

        // 6. Cash Flow Gap
		let netSpendable = sumAccounts(netWithdrawals) + totalRMD + fixedInc - totalTax
        let gap = targetSpend - netSpendable;
        
		inspectForErrors({netSpendable: netSpendable, gap: gap, wdIRA: wdIRA, 
			totalTax: totalTax});

		
        if (gap > 0.10) {
			// We need to do more withdrawals.
			withdrawStrategy.order = ['Brokerage', 'Cash', 'IRA', 'Roth'];
			withdrawStrategy.weights = [40, 60, 0, 0];
			withdrawStrategy.taxrate = [capitalGainsRate + nominalStateTaxAtLimit, 0, nominalTaxRate, 0];
			withdrawals = calculateWithdrawals(curBalances, gap, withdrawStrategy);
			// Capture any shortfall
			shortfall = withdrawals.shortfall;
			
			netWithdrawals = accumulateWithdrawals( [netWithdrawals, withdrawals])
			applyWithdrawals(curBalances, withdrawals);
        }
		
		// Recheck tax calculations due to possible additional withdrawals - and we now
		// have a more accurate income picture.
		tax = calculateTax(fixedInc, netWithdrawals.IRA + totalRMD + taxableInterest, capitalGains + taxableDividends, status, age1, age2, cpiRate);
		inspectForErrors(tax);
		
		// sumAccounts(netWithdrawals) + totalRMD + fixedInc - totalTax

		totalIncome = Math.max(1, fixedInc + netWithdrawals.IRA + pension + taxableDividends + taxableInterest + netWithdrawals.Roth + netWithdrawals.Cash + netWithdrawals.Brokerage + totalRMD);
		
		inspectForErrors({totalIncome: totalIncome});
		
		nominalTaxRate = totalTax / tax.magi;		

        // 7. Updates
		
		netIncome = totalIncome - totalTax;
		let surplus = Math.max(0, netIncome - spendGoal)
		
		//!!! Remove withdrawals proportionately. RMDs have already been withdrawn.
		const ira1_ratio = (balance.IRA1/(balance.IRA1+balance.IRA2||1))
        netWithdrawals.IRA1 = Math.max(0, netWithdrawals.IRA * ira1_ratio);
        netWithdrawals.IRA2 = Math.max(0, netWithdrawals.IRA * (1 - ira1_ratio));
		
		// Withdraw from the balances.
		applyWithdrawals(balance, netWithdrawals)
		

		let growthRates = {IRA: inputs.growth, IRA1: inputs.growth, IRA2: inputs.growth, 
						   Brokerage: inputs.growth, Cash: inputs.cashYield, Roth: inputs.growth}
		
		// Grow Balances
		let gains = applyGrowth( balance, growthRates)
		
 	
		// Accrue dividends to cash
		gains.Cash += taxableDividends
        balance.Cash +=  taxableDividends;
        balance.magiHistory.push(tax.magi);
        totals.tax += totalTax;
        totals.gross += (totalIncome);
        totals.spend += (targetSpend - Math.max(0, gap));
		balance.Roth += surplus;
		
		let totalWealth = (balance.IRA1 + balance.IRA2 + Math.max(0, balance.Brokerage -   balance.BrokerageBasis)) * (1-nominalTaxRate) + balance.Roth + balance.Cash + balance.BrokerageBasis

		if (netIncome < targetSpend || totalWealth < (targetSpend * 2)) {
			totals.success = false;
			totals.failedInYear.push(startYear + y)
		} else {
			totals.yearsfunded += 1
		}

        log.push({
            year: startYear + y,
            age1: alive1 ? age1 : 'â€”',
            age2: alive2 ? age2 : 'â€”',
			status: status,
            SSincome: fixedInc,
			pension: pension,
            spendGoal: targetSpend,
			magi: tax.magi,
			totalIncome: totalIncome,
            netIncome: netIncome,	
            surplus: surplus,	
			'RMD1-': rmd1,
			'RMD2-': rmd2,
            'RMDwd': totalRMD,
			'IRA1-': netWithdrawals.IRA1,
			'IRA2-': netWithdrawals.IRA2,
            // 'IRAwd': netWithdrawals.IRA,
            'Brokerage-': netWithdrawals.Brokerage,
			'CapGains': capitalGains,
            'RothWD': netWithdrawals.Roth,
            'CashWD': netWithdrawals.Cash,
			'cashD+I': taxableDividends + taxableInterest,
			IRMAA: irmaa,
			FedTax: tax.fed,
			StateTax: tax.state,
            totalTax: totalTax,
            'fedLimit': tax.fedLimit,
			'stateLimit': tax.stLimit,
			'FedRate%': tax.fedRate,
			'StateRate%': tax.stRate,
			'NominalRate%': nominalTaxRate,
			'SumTaxes': cumulativeTaxes,
            IRA1: balance.IRA1,
			IRA2: balance.IRA2,
			TotalIRA: balance.IRA1 + balance.IRA2,
			Cash: balance.Cash,
			Roth: balance.Roth,
            Brokerage: balance.Brokerage,
            Basis: balance.BrokerageBasis,
            totalWealth: totalWealth,
			cashG: gains.Cash,
			brokerageG: gains.Brokerage,
			rothG: gains.Roth,
			rothConv: surplus
        });

    } // end large for for year by year.

    return { log, totals, finalNW: log[log.length-1].totalWealth };
}

/**
 * Calculates Federal, California State, and IRMAA taxes.
 * * @param {Object} params - Input parameters
 * @param {number} params.yearOffset - Number of years from base (2026) to adjust for cpi/Inflation.
 * @param {string} params.filingStatus - 'MFJ' (Married Filing Jointly) or 'Single'.
 * @param {Array}  params.ages - Array of ages [age1, age2] or [age1] if single.
 * @param {number} params.earnedIncome - Total of W2, IRA/401k withdrawals, and RMDs.
 * @param {number} params.ss1 - Social Security for Person 1.
 * @param {number} params.ss2 - Social Security for Person 2 (0 if Single).
 * @param {number} params.ordDivInterest - Interest and Ordinary Dividends.
 * @param {number} params.qualifiedDiv - Qualified Dividends (taxed at lower rates Federally).
 * @param {number} params.capGains - Net Long Term Capital Gains.
 * @param {number} params.taxExemptInterest - Muni bond interest (non-taxable but used for SS/IRMAA/CA).
 * @param {number} params.hsaContrib - Total HSA contributions (deductible Fed, taxable CA).
 * @param {number} params.cpi - Annual cpi/Inflation rate (e.g., 0.025 for 2.5%).
 */
function calculateTaxes(params) {
    const { 
        yearOffset, filingStatus, ages, earnedIncome, ss1, ss2, 
        ordDivInterest, qualifiedDiv, capGains, taxExemptInterest, 
        hsaContrib, cpi 
    } = params;

    const inflationFactor = Math.pow(1 + cpi, yearOffset);
    const totalSS = ss1 + ss2;

    // --- 1. FEDERAL SOCIAL SECURITY TAXABILITY ---
    // Formula: Provisional Income = AGI (excluding SS) + TaxExemptInterest + 50% of SS
    const provisionalIncome = earnedIncome + ordDivInterest + qualifiedDiv + capGains + taxExemptInterest - hsaContrib + (totalSS * 0.5);
    
    let taxableSS = 0;
	//!!! TODO This logic can be replace with calculateProgressive using the provisionalIncome?!
	taxableSS = calculateProgressive('SOCIALSECURITY', filingStatus, provisionalIncome, inflationFactor).cumulative
    const ssThreshold1 = (filingStatus === 'MFJ' ? 32000 : 25000) * inflationFactor;
    const ssThreshold2 = (filingStatus === 'MFJ' ? 44000 : 34000) * inflationFactor;

    if (provisionalIncome > ssThreshold2) {
        taxableSS = Math.min(0.85 * totalSS, (0.85 * (provisionalIncome - ssThreshold2)) + Math.min(6000 * inflationFactor, 0.5 * (ssThreshold2 - ssThreshold1)));
    } else if (provisionalIncome > ssThreshold1) {
        taxableSS = Math.min(0.5 * totalSS, 0.5 * (provisionalIncome - ssThreshold1));
    }

    // --- 2. FEDERAL TAX CALCULATION ---
    const fedAGI = earnedIncome + ordDivInterest + qualifiedDiv + capGains + taxableSS - hsaContrib;
    
    // Standard Deduction with Age 65+ bump
    let fedStdDeduct = TAXData['FEDERAL'][filingStatus].std * inflationFactor;
    ages.forEach(age => { if (age >= TAXData['FEDERAL'][filingStatus].age) fedStdDeduct += (TAXData['FEDERAL'][filingStatus].stdbump * inflationFactor); });

    const fedTaxableIncome = Math.max(0, fedAGI - fedStdDeduct);
    const prefIncome = qualifiedDiv + capGains; // Income taxed at 0/15/20%
    const ordinaryTaxable = Math.max(0, fedTaxableIncome - prefIncome);

    const fedOrdinaryTax = calcProgressive(ordinaryTaxable, getFedBrackets(filingStatus, inflationFactor));
	let testFedTax = calculateProgressive('FEDERAL', filingStatus, ordinaryTaxable, inflationFactor).cumulative
    const fedPrefTax = calcPrefTax(ordinaryTaxable, prefIncome, filingStatus, inflationFactor);
    const totalFedTax = fedOrdinaryTax + fedPrefTax;

    // --- 3. (CALIFORNIA) STATE TAX CALCULATION ---
    // CA Add-backs: HSA is taxable. Muni interest is taxable (assuming out-of-state for conservative estimate).
    // CA Subtractions: Social Security is 100% exempt.
    const caAGI = (fedAGI - taxableSS) + hsaContrib + taxExemptInterest;
    const caStdDeduct = TAXData[STATEname][filingStatus].std * inflationFactor;
    const caTaxableIncome = Math.max(0, caAGI - caStdDeduct);
    const caTax = calcProgressive(caTaxableIncome, getCABrackets(filingStatus, inflationFactor));
	let testCAResult = calculateProgressive(STATEname, filingStatus, caTaxableIncome, inflationFactor).cumulative
	

    // --- 4. IRMAA CALCULATION ---
    // MAGI for IRMAA = Fed AGI + Tax-Exempt Interest
    const irmaaMAGI = fedAGI + taxExemptInterest;
    const irmaaAnnualSurcharge = calcIRMAA(irmaaMAGI, filingStatus, inflationFactor) * 12;

    return {
        fedAGI: Math.round(fedAGI),
        fedTax: Math.round(totalFedTax),
        caTax: Math.round(caTax),
        irmaa: Math.round(irmaaAnnualSurcharge),
        totalTax: Math.round(totalFedTax + caTax + irmaaAnnualSurcharge),
        effectiveRate: ((totalFedTax + caTax + irmaaAnnualSurcharge) / (fedAGI + totalSS + taxExemptInterest) * 100).toFixed(2) + '%'
    };
}

// --- HELPER FUNCTIONS ---

function calcProgressive(taxable, brackets) {
    let tax = 0;
    let previousLimit = 0;
    for (const b of brackets) {
        if (taxable > previousLimit) {
            const amountInBracket = Math.min(taxable, b.limit) - previousLimit;
            tax += amountInBracket * b.rate;
            previousLimit = b.limit;
        }
    }
    return tax;
}

function calcPrefTax(ordTaxable, prefIncome, status, idx) {
    // Simplified Fed Capital Gains Brackets (0%, 15%, 20%)
    const thresholds = (status === 'MFJ' ? [94050, 583750] : [47025, 518900]).map(v => v * idx);
    let tax = 0;
    let remainingPref = prefIncome;
    let currentLevel = ordTaxable;

    // 0% tier
    const zeroCap = Math.max(0, thresholds[0] - currentLevel);
    remainingPref -= Math.min(remainingPref, zeroCap);
    currentLevel += Math.min(prefIncome, zeroCap);

    // 15% tier
    if (remainingPref > 0) {
        const fifteenCap = Math.max(0, thresholds[1] - currentLevel);
        const amountAtFifteen = Math.min(remainingPref, fifteenCap);
        tax += amountAtFifteen * 0.15;
        remainingPref -= amountAtFifteen;
    }
    // 20% tier
    if (remainingPref > 0) tax += remainingPref * 0.20;
    return tax;
}


function getFedBrackets(status, idx) {
    return status === 'MFJ' 
        ? [{limit: 23850*idx, rate: 0.1}, {limit: 96950*idx, rate: 0.12}, {limit: 206700*idx, rate: 0.22}, {limit: 394600*idx, rate: 0.24}, {limit: 1e9, rate: 0.32}]
        : [{limit: 11925*idx, rate: 0.1}, {limit: 48475*idx, rate: 0.12}, {limit: 103350*idx, rate: 0.22}, {limit: 197300*idx, rate: 0.24}, {limit: 1e9, rate: 0.32}];
}

function getCABrackets(status, idx) {
    const base = [{limit: 10412, rate: 0.01}, {limit: 24684, rate: 0.02}, {limit: 38959, rate: 0.04}, {limit: 54081, rate: 0.06}, {limit: 68348, rate: 0.08}, {limit: 349137, rate: 0.093}, {limit: 418961, rate: 0.103}, {limit: 698271, rate: 0.113}, {limit: 1e9, rate: 0.123}];
    return base.map(b => ({ limit: b.limit * (status === 'MFJ' ? 2 : 1) * idx, rate: b.rate }));
}

// Do a progressive calculation on the bracket.
function calculateProgressive(entity, status, amount, inflation=1, ratecreep=1) {
 
    let brks = getRateBracket(entity, status)
    if (!brks) {
        return { cumulative: 0, total: 0, marginal: 0, limit: 0, error: `Invalid entity (${entity}) or status (${status})` };
    }
    
    let prevLimit = 0;
    let cumulative = 0;
    let marginalRate = 0;
    
    for (let b of brks) {
        let currentLimit = b.l * inflation;
        
        if (amount <= currentLimit) {
            cumulative += (amount - prevLimit) * b.r * ratecreep;
            marginalRate = b.r * ratecreep;
            prevLimit = currentLimit;
            break;
        } else {
            cumulative += (currentLimit - prevLimit) * b.r * ratecreep;
            marginalRate = b.r * ratecreep;
            prevLimit = currentLimit;
        }
    }
    
    return { cumulative, total: cumulative, marginal: marginalRate, limit: prevLimit }
}

function calculateTax(fixed, ira, gains, status, a1, a2, inflation=1, ratecreep=1) {
    let std = TAXData["FEDERAL"]?.[status]?.std;
    if (a1 >= TAXData["FEDERAL"]?.[status]?.age) std += TAXData["FEDERAL"][status].stdbump * inflation;
    if (a2 >= TAXData["FEDERAL"]?.[status]?.age && status === 'MFJ') std += TAXData["FEDERAL"][status].stdbump * inflation;

    let agi = fixed + ira + gains;
    let taxable = Math.max(0, agi - std);
	
	let calc = calculateProgressive('FEDERAL', status, taxable, inflation);
	let fedTax = calc.cumulative;
	let fedRate = calc.marginal;
	let fedLimit = calc.limit;
	
	
	// Calculate (CA) State Tax
	// State basis is calculated differently.
	let stStd = TAXData[STATEname]?.[status]?.std;
	
	//!!!TODO: This is wrong. It should be calculated with the state deduction(s).
	let stAGI = taxable;
	calc = calculateProgressive(STATEname, status, stAGI, inflation);
	let stTax = calc.cumulative;
	let stLimit = calc.limit;
	let stRate = calc.marginal;
	
	let totalTax = fedTax + stTax
	
    return { total: totalTax, fed: fedTax, state: stTax, magi: agi, stagi: stAGI, 
			fedLimit: fedLimit, stLimit: stLimit, fedRate: fedRate, stRate: stRate};
}

function calcIRMAA(magi, status, inflation) {
	let irmaalimit = findUpperLimitByAmount( 'IRMAA', status, magi, inflation)
	return irmaalimit.rate * inflation * 12
}

/** UI CONTROLS **/
function getInputs() {
	// TODO: If we override these values, we should update the UI 
	let spendChange = +val('spendChange')
	if (spendChange < -25 || spendChange > 25) spendChange = 0
	let brokerage = +val('brokerage');
	let brokeragebasis = +val('basis');
	if (brokerage <= 0.01) basis = 0;
	if (basis > brokerage) basis = brokerage;
    return {
		STATEname: val('STATEname'), 	
		strategy: val('strategy'), 	
		nYears: +val('nYears'), 
		stratRate: +val('stratRate')/100.0,
        birthyear1: +val('birthyear1'), 
		die1: +val('die1'), 
		birthyear2: +val('birthyear2'), 
		die2: +val('die2'),
        IRA1: +val('ira1'), 
		IRA2: +val('ira2'), 
		Roth: +val('roth'),
        Brokerage: brokerage, 
		BrokerageBasis: brokeragebasis, 
		Cash: +val('cash'),
        ss1: +val('ss1'), 
		ss1Age: +val('ss1Age'), 
		ss2: +val('ss2'), 
		ss2Age: +val('ss2Age'),
        pensionAnnual: +val('pensionAnnual'), 
		survivorPct: +val('survivorPct'), 
		spendGoal: +val('spendGoal'),
		spendChange: 1 + (spendChange/100.0), 
		iraBaseGoal: +val('iraBaseGoal'),
        inflation: +val('inflation')/100.0, 
		cpi: +val('cpi')/100.0, 
		growth: +val('growth')/100.0, 
		cashYield: +val('cashYield')/100.0,
		dividendRate: +val('dividendRate')/100.0,
		ssFailYear: +val('ssFailYear'), 
		ssFailPct: +val('ssFailPct')/100.0,
		startInYear: +val('startInYear')
    };
}

function runSimulation() {
    let res = simulate(getInputs());
    updateTable(res.log);
    updateStats(res.totals, res.finalNW);
    updateCharts(res.log);
}

function runOptimizer() {
    let base = getInputs();
    let results = [];
    for (let n of [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 20, 25]) {
        base.strategy = 'fixed';
        base.nYears = n;
        results.push({ 
		strategy: "Fixed", parameter: n, unit: "years", ...simulate(base) });
    }
    let html = results.map(r => `
        <tr>
            <td>${r.strategy} ${r.parameter} ${r.unit}</td>
            <td>$${Math.round(r.totals.tax).toLocaleString()}</td>
            <td>$${Math.round(r.finalNW).toLocaleString()}</td>
            <td>${(r.totals.tax/r.totals.gross*100).toFixed(1)}%</td>
			<td>${r.totals.yearsfunded}</td>
			<td>${r.totals.success ? 'ðŸŸ¢' : 'ðŸš¨'}</td>
			<td>${r.totals.yearstested}</td>
        </tr>
    `).join('');
    document.querySelector('#opt-table tbody').innerHTML = html;
    showTab('tab-opt');
}


function updateTable(log) {
	const oldTable = document.getElementById('main-table');

	if (!log || log.length === 0) {
		if (oldTable) {
		  oldTable.remove();
		}
		return null;
	}

	const table = document.createElement('table');
	table.border = '1';
	table.id = 'main-table';
  
	const keys = Object.keys(log[0]);

	// Create header
	const thead = table.createTHead();
	const headerRow = thead.insertRow();
	
	const tooltips = {
		'RMD-': 'Total of all RMDs (positive indicate withdrawals)',
		'Brokerage': 'Withdrawals are negative',
		'IRMAA': 'First two years are presumed the same as the 3rd year on.',
		'SpendGoal': 'With inflation, this amount increases.',
		'Roth': 'Positive amounts are deposits, negative are withdrawals',
		'totalTax': 'Federal,IRMAA,NIIT,CapGains & IRMAA are all included.',
		'NominalTax%': 'TotalTax/TotalGrossIncome'
	};

	keys.forEach(key => {
		if (!key.startsWith('-')) {
			const th = document.createElement('th');
			th.textContent = key.endsWith('!') ? key.slice(0, -1) : key;
			
			if (tooltips[key]) {
				th.title = tooltips[key];
			}
			
			headerRow.appendChild(th);
		}
	});
  
	// Create body
	const tbody = table.createTBody();
	log.forEach(row => {
	  const tr = tbody.insertRow();
	  
	  // Check conditions for highlighting
	  const spendGoal = row['SpendGoal'] ?? row['spendGoal'];
	  const netIncome = row['NetIncome'] ?? row['netIncome'];
	  const totalWealth = row['TotalWealth'] ?? row['totalWealth'];
	  const age1 = row['Age1'] ?? row['age1'];
	  const age2 = row['Age2'] ?? row['age2'];
	  
	  const shouldHighlightPink = (spendGoal > netIncome) || (totalWealth < spendGoal);
	  const shouldHighlightYellow = (age1 === 'â€”' || age2 === 'â€”');
	  
	  // Pink takes priority over yellow
	  if (shouldHighlightPink) {
		tr.style.backgroundColor = '#ffb6c180';  // Light pink
	  } else if (shouldHighlightYellow) {
		tr.style.backgroundColor = '#ffff99';  // Light yellow
	  }
	  
	  keys.forEach(key => {
		if (!key.startsWith('-')) {
		  const td = tr.insertCell();
		  const value = row[key];
		  
		  // Check if key indicates percentage
		  const isPercent = key.toLowerCase().includes('%');
		  const isYear = key.toLowerCase().includes('yr') || key.toLowerCase().includes('year');
		  
		  if (value != null && !isNaN(value)) {
			if (isPercent) {
			  // Format as percentage (convert from decimal)
			  td.textContent = (value * 100).toFixed(2);
			} else {
			  // Format as whole number
			  if (isYear) {
				td.textContent = value;
			  } else {
				td.textContent = Math.round(value).toLocaleString();
			  }
			}
		  } else {
			td.textContent = value ?? '';
		  }
		  
		  tr.appendChild(td);
		}
	  });
	});
  
  if (oldTable) {
    oldTable.replaceWith(table);
  }
  
  return table;
}

/*calculateInflationAdjustedWithdrawal:
* given the parameters, determines the first year withdrawal (subsequent years are 
* adjusted for inflation).  At that rate, the asset would reach zero in *years*
*/
function calculateInflationAdjustedWithdrawal(principal, growthRate, inflationRate, years) {
    // Calculate real growth rate
    const realRate = growthRate - inflationRate;
	
	// Special case: principal is negative.
	if (principal <= 0) return 0;
    
    // Special case: when real growth is zero
    if (Math.abs(realRate) < 0.0001) {
        return principal / years;
    }
    
    // General case: first year withdrawal in today's dollars
    const denominator = 1 - Math.pow(1 + realRate, -years);
    const firstYearWithdrawal = principal * (realRate / denominator);
    
    return firstYearWithdrawal;
}


function updateStats(totals, finalNW, minNetWorth = 100000) {
    document.getElementById('stat-rate').innerText = (totals.tax / totals.gross * 100).toFixed(1) + '%';
    document.getElementById('stat-spend').innerText = '$' + Math.round(totals.spend).toLocaleString();
    document.getElementById('stat-tax').innerText = '$' + Math.round(totals.tax).toLocaleString();
    document.getElementById('stat-nw').innerText = '$' + Math.round(finalNW).toLocaleString();
    document.getElementById('stat-years').innerText = totals.yearstested;
    document.getElementById('stat-yearsfunded').innerText = totals.yearsfunded;
	let indicator = 'ðŸ›‘ FAILED ';
	if (totals.yearsfunded >= totals.yearstested && finalNW > minNetWorth) {
		indicator = 'ðŸŸ¢ SUCCESS ';
	}
    document.getElementById('stat-success').innerText = indicator;

}

let assetChart, taxChart;
function updateCharts(log) {
    const ctxA = document.getElementById('chartAssets').getContext('2d');
    if (assetChart) assetChart.destroy();
    assetChart = new Chart(ctxA, {
        type: 'line',
        data: {
            labels: log.map(r => r.year),
            datasets: [
                { label: 'IRAs', data: log.map(r => r.TotalIRA), borderColor: '#e67e22', fill: false },
                { label: 'Roth', data: log.map(r => r.Roth), borderColor: '#000000', fill: false },
                { label: 'Brokerage', data: log.map(r => r.Brokerage), borderColor: '#2980b9', fill: false },
                { label: 'Cash', data: log.map(r => r.Cash), borderColor: '#27ae60', fill: false },
                { label: 'TotalWealth', data: log.map(r => r.totalWealth), borderColor: '#888888', fill: false }
            ]
        },
        options: {
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return context.dataset.label + ': ' + 
                                   Math.round(context.parsed.y).toLocaleString();
                        }
                    }
                }
/*				,
			  legend: {
				labels: {
				  usePointStyle: true,
				  pointStyle: 'circle',
					fill: false,
				  boxWidth: 10,
				  boxHeight: 10,

				  padding: 16
					}
				} // legend
*/
            } // plugins
        } // options
    });
    
    const ctxT = document.getElementById('chartTaxSpend').getContext('2d');
    if (taxChart) taxChart.destroy();
taxChart = new Chart(ctxT, {
    data: {  // Removed type from here
        labels: log.map(r => r.year),
        datasets: [
            { 
                label: 'Fed Tax', 
                data: log.map(r => r.FedTax),
                type: 'bar',  // Type on dataset
                backgroundColor: '#e74c3c80',
                stack: 'taxes',
                order: 2
            },
            { 
                label: 'State Tax', 
                data: log.map(r => r.StateTax),
                type: 'bar',  // Type on dataset
                backgroundColor: '#4BC0C0B3',
                stack: 'taxes',
                order: 2
            },
            { 
                label: 'IRMAA', 
                data: log.map(r => r.IRMAA),
                type: 'bar',  // Type on dataset
                backgroundColor: '#000000D0',
                stack: 'taxes',
                order: 2
            },

/*			
            { 
                label: 'Fixed Income', 
                data: log.map(r => r.pension + r.SSincome),
                type: 'line',  // Type on dataset
                borderColor: '#272727', 
                fill: false, 
				stack: false,
                borderWidth: 3,
                order: 1
                // NO stack property
            },
*/			
            { 
                label: 'Spendable Income', 
                data: log.map(r => r.netIncome),
                type: 'line',  // Type on dataset
                borderColor: '#27ae60', 
                fill: false, 
				stack: false,
                borderWidth: 3,
                order: 1
                // NO stack property
            }
        ]
    },
    options: {
        scales: {
            x: {
                stacked: true
            },
            y: {
                stacked: true,
                ticks: {
                    callback: function(value) {
                        return Math.round(value).toLocaleString();
                    }
                }
            }
        },
        plugins: {
			tooltip: {
				callbacks: {
					label: function(context) {
						return context.dataset.label + ': ' + 
							   Math.round(context.parsed.y).toLocaleString();
					}
				}
			},
		  legend: {
			labels: {
			  usePointStyle: true,
			  pointStyle: 'circle',

			  boxWidth: 10,
			  boxHeight: 10,

			  padding: 16
				}
			} // legend
		} // plugins
	} // options
	});	// chart
}

function val(id) { return document.getElementById(id)?.value; }

function showTab(id) {
    // 1. Hide all tab content cards
    document.querySelectorAll('.tab-content, .card').forEach(c => { 
        if(c.id.startsWith('tab-')) c.classList.add('hidden'); 
    });
    // 2. Show the selected card
    document.getElementById(id).classList.remove('hidden');

    // 3. Update the active button styling (Fixed Selector)
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    const activeBtn = document.querySelector(`.tab-btn[onclick*="${id}"]`);
    if (activeBtn) activeBtn.classList.add('active');
}


function toggleStrategyUI() {
    let m = val('strategy');
    document.getElementById('ui-fixed').classList.toggle('hidden', m !== 'fixed');
    document.getElementById('ui-bracket').classList.toggle('hidden', m !== 'bracket');
	// document.getElementById('ui-maximize').classList.toggle('hidden', !(m === 'baseline'));
}


/* Save, Import and Export settings/Scenarios
*/
///////////////////////////////////////////////
// ============================================================================


// ============================================================================
// MESSAGE DISPLAY FUNCTIONS
// ============================================================================

/**
 * Displays a colored message in the scenario message area
 * @param {string} message - The text message to display
 * @param {string} type - Message type: 'success' (green), 'error' (red), or 'warning' (yellow)
 *                        Default is 'success'
 * Auto-hides the message after 5 seconds
 */
function showMessage(message, type = 'success') {
    const messageDiv = document.getElementById('scenarioMessage');
    messageDiv.textContent = message;
    messageDiv.className = `scenario-message ${type}`;
    messageDiv.style.display = 'block';
    
    // Auto-hide after 15 seconds
    setTimeout(() => {
        messageDiv.style.display = 'none';
    }, 15000);
}

/**
 * Manually clears and hides the message display area
 * No parameters
 */
function clearMessage() {
    const messageDiv = document.getElementById('scenarioMessage');
    messageDiv.style.display = 'none';
}

// ============================================================================
// STORAGE ACCESS FUNCTIONS
// ============================================================================

/**
 * Retrieves all scenarios from the new storage key
 * No parameters
 * @returns {Object} Object containing scenario data keyed by scenario name
 *                   Returns empty object {} if no scenarios exist
 */
function getSavedScenarios() {
    const saved = localStorage.getItem(STORAGE_KEY);
    return saved ? JSON.parse(saved) : {};
}

/**
 * Retrieves all scenarios from the old storage key (previous version)
 * No parameters
 * @returns {Object} Object containing old scenario data keyed by scenario name
 *                   Returns empty object {} if no old scenarios exist
 */
function getOldScenarios() {
    const oldSaved = localStorage.getItem(OLD_STORAGE_KEY);
    return oldSaved ? JSON.parse(oldSaved) : {};
}

/**
 * Retrieves and merges scenarios from both old and new storage locations
 * Old scenarios are marked with isOldStorage flag and version 1
 * No parameters
 * @returns {Object} Merged object containing all scenarios from both storage keys
 *                   Old scenarios have isOldStorage: true property added
 */
function getAllScenarios() {
    const newScenarios = getSavedScenarios();
    const oldScenarios = getOldScenarios();
    
    // Merge old scenarios, marking them as version 1
    const allScenarios = { ...newScenarios };
    
    for (const [name, scenario] of Object.entries(oldScenarios)) {
        // If scenario doesn't have a version property, it's from old version
        if (!scenario.version) {
            allScenarios[name] = {
                version: 1,
                data: scenario.data || scenario, // Handle different old formats
                savedAt: scenario.savedAt || 'Unknown',
                isOldStorage: true // Flag to identify old storage scenarios
            };
        }
    }
    
    return allScenarios;
}

// ============================================================================
// SCENARIO VALIDATION FUNCTIONS
// ============================================================================

/**
 * Checks if a scenario is compatible with the current version
 * @param {Object} scenario - Scenario object with version property
 * @returns {boolean} True if scenario.version matches SCENARIO_VERSION, false otherwise
 */
function isCompatibleScenario(scenario) {
    return scenario.version === SCENARIO_VERSION;
}

/**
 * Escapes single and double quotes in a string for safe use in HTML attributes
 * @param {string} str - String to escape
 * @returns {string} String with ' replaced by \' and " replaced by \"
 */
function escapeQuotes(str) {
    return str.replace(/'/g, "\\'").replace(/"/g, '\\"');
}

// ============================================================================
// INITIALIZATION FUNCTION
// ============================================================================

/**
 * Checks for old scenarios on page load and displays warning if found
 * Called automatically on DOMContentLoaded event
 * Does not auto-delete - user must use Manage Scenarios to delete
 * No parameters
 */
function migrateOldScenarios() {
    const oldScenarios = localStorage.getItem(OLD_STORAGE_KEY);
    
    if (oldScenarios) {
        try {
            const parsed = JSON.parse(oldScenarios);
            const scenarioCount = Object.keys(parsed).length;
            
            if (scenarioCount > 0) {
                showMessage(
                    `Found ${scenarioCount} old scenario(s) from previous version. These are incompatible. Use "Manage Scenarios" to review and delete them.`,
                    'warning'
                );
            }
        } catch (e) {
            localStorage.removeItem(OLD_STORAGE_KEY);
        }
    }
}

// ============================================================================
// MAIN USER ACTION FUNCTIONS
// ============================================================================

/**
 * Saves current form inputs as a named scenario to new storage
 * Uses scenario name from input field #scenarioName, or generates timestamp name if empty
 * Calls getInputs() to retrieve current form values
 * Displays success or error message
 * No parameters
 */
function saveScenario() {
    const inputs = getInputs();
	const scenarioName = document.getElementById('scenarioName').value.trim() || 
                    `${new Date().toISOString().slice(0, 19).replace('T', ' ')}`;
    
    try {
        const scenarios = getSavedScenarios();
        
        scenarios[scenarioName] = {
            version: SCENARIO_VERSION,
            data: inputs,
            savedAt: new Date().toISOString()
        };
        
        localStorage.setItem(STORAGE_KEY, JSON.stringify(scenarios));
        
        showMessage(`Scenario "${scenarioName}" saved successfully!`, 'success');
        document.getElementById('scenarioName').value = '';
    } catch (error) {
        showMessage(`Failed to save scenario: ${error.message}`, 'error');
    }
}

/**
 * Prompts user to select and load a compatible scenario
 * Filters out incompatible versions before displaying list
 * Shows error if no compatible scenarios exist
 * No parameters
 */
function loadScenario() {
    try {
        const scenarios = getSavedScenarios();
        const scenarioNames = Object.keys(scenarios);
        
        if (scenarioNames.length === 0) {
            showMessage('No saved scenarios found.', 'error');
            return;
        }
        
        const compatibleScenarios = scenarioNames.filter(name => 
            scenarios[name].version === SCENARIO_VERSION
        );
        
        if (compatibleScenarios.length === 0) {
            showMessage('No compatible scenarios found. All saved scenarios are from an older version.', 'error');
            return;
        }
        
        let selection = prompt('Enter scenario name to load:\n\n' + compatibleScenarios.join('\n'));
        
        if (selection && scenarios[selection]) {
            if (scenarios[selection].version !== SCENARIO_VERSION) {
                showMessage('This scenario is from an incompatible version and cannot be loaded.', 'error');
                return;
            }
            applyScenario(scenarios[selection].data);
            showMessage(`Scenario "${selection}" loaded successfully!`, 'success');
        } else if (selection) {
            showMessage('Scenario not found.', 'error');
        }
    } catch (error) {
        showMessage(`Failed to load scenario: ${error.message}`, 'error');
    }
}

/**
 * Applies scenario data to form input fields
 * Handles percentage conversions for specific fields (multiplies by 100 for display)
 * Triggers recalculate() function if it exists
 * @param {Object} data - Scenario data object with keys matching form input IDs
 */
function applyScenario(data) {
    for (const [key, value] of Object.entries(data)) {
        const element = document.getElementById(key);
        if (element) {
            // Handle percentage values (multiply by 100 for display)
            if (['stratRate', 'spendChange', 'inflation', 'cpi', 'growth', 
                 'cashYield', 'dividendrate', 'ssFailPct'].includes(key)) {
                element.value = (value * 100).toFixed(2);
            } else {
                element.value = value;
            }
        }
    }
    
    // Trigger any recalculations your app needs
    if (typeof recalculate === 'function') {
        recalculate();
    }
}

// ============================================================================
// SCENARIO MANAGEMENT FUNCTIONS
// ============================================================================

/**
 * Opens modal dialog showing all scenarios from both storage locations
 * Displays table with Name, Saved Date, Version, Storage location, and Actions
 * Shows compatibility status with color coding (green=compatible, red=incompatible)
 * Shows bulk action buttons if incompatible or old scenarios exist
 * No parameters
 */
function manageScenarios() {
    const scenarios = getAllScenarios();
    const modal = document.getElementById('scenarioModal');
    const content = document.getElementById('scenarioListContent');
    
    if (Object.keys(scenarios).length === 0) {
        content.innerHTML = '<p>No saved scenarios.</p>';
    } else {
        let html = '<table style="width: 100%; border-collapse: collapse;">';
        html += '<tr><th style="text-align: left; padding: 8px; border-bottom: 2px solid #ddd;">Name</th>';
        html += '<th style="text-align: left; padding: 8px; border-bottom: 2px solid #ddd;">Saved</th>';
        html += '<th style="text-align: center; padding: 8px; border-bottom: 2px solid #ddd;">Version</th>';
        html += '<th style="text-align: center; padding: 8px; border-bottom: 2px solid #ddd;">Storage</th>';
        html += '<th style="text-align: center; padding: 8px; border-bottom: 2px solid #ddd;">Actions</th></tr>';
        
        for (const [name, scenario] of Object.entries(scenarios)) {
            const savedDate = scenario.savedAt !== 'Unknown' 
                ? new Date(scenario.savedAt).toLocaleString() 
                : 'Unknown';
            const version = scenario.version || 1;
            const isCurrent = version === SCENARIO_VERSION;
            const isOldStorage = scenario.isOldStorage || false;
            
            const versionBadge = isCurrent 
                ? `<span style="color: green; font-weight: bold;">v${version} âœ“</span>` 
                : `<span style="color: red;">v${version} âœ—</span>`;
            
            const storageBadge = isOldStorage
                ? `<span style="color: orange; font-size: 0.9em;">OLD</span>`
                : `<span style="color: blue; font-size: 0.9em;">NEW</span>`;
            
            const rowStyle = isCurrent ? '' : 'background-color: #ffeeee;';
            
            html += `<tr style="${rowStyle}">
                <td style="padding: 8px; border-bottom: 1px solid #eee;">${name}</td>
                <td style="padding: 8px; border-bottom: 1px solid #eee;">${savedDate}</td>
                <td style="padding: 8px; border-bottom: 1px solid #eee; text-align: center;">${versionBadge}</td>
                <td style="padding: 8px; border-bottom: 1px solid #eee; text-align: center;">${storageBadge}</td>
                <td style="padding: 8px; border-bottom: 1px solid #eee; text-align: center;">
                    <button onclick="loadScenarioByName('${escapeQuotes(name)}')" ${!isCurrent ? 'disabled title="Incompatible version"' : ''}>Load</button>
                    <button onclick="deleteScenario('${escapeQuotes(name)}')">Delete</button>
                    <button onclick="exportScenario('${escapeQuotes(name)}')">Export</button>
                </td>
            </tr>`;
        }
        html += '</table>';
        
        const incompatibleCount = Object.values(scenarios).filter(s => !isCompatibleScenario(s)).length;
        const oldStorageCount = Object.values(scenarios).filter(s => s.isOldStorage).length;
        
        if (incompatibleCount > 0 || oldStorageCount > 0) {
            html += `<div style="margin-top: 15px; padding: 10px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px;">`;
            
            if (incompatibleCount > 0) {
                html += `<strong>âš ï¸ ${incompatibleCount} incompatible scenario(s) found</strong><br>`;
            }
            if (oldStorageCount > 0) {
                html += `<strong>ðŸ“¦ ${oldStorageCount} scenario(s) in old storage format</strong><br>`;
            }
            
            html += `<button onclick="deleteIncompatibleScenarios()" style="margin-top: 5px;">Delete All Incompatible Scenarios</button>`;
            
            if (oldStorageCount > 0) {
                html += ` <button onclick="deleteOldStorageKey()" style="margin-top: 5px;">Clear Old Storage</button>`;
            }
            
            html += `</div>`;
        }
        
        content.innerHTML = html;
    }
    
    modal.style.display = 'block';
}

/**
 * Loads a specific scenario by name from either storage location
 * Validates version compatibility before loading
 * Closes modal and shows success/error message
 * @param {string} name - Name of the scenario to load
 */
function loadScenarioByName(name) {
    try {
        const scenarios = getAllScenarios();
        if (scenarios[name]) {
            if (!isCompatibleScenario(scenarios[name])) {
                showMessage(`Scenario "${name}" is from an incompatible version (v${scenarios[name].version || 1}) and cannot be loaded. Current version: v${SCENARIO_VERSION}`, 'error');
                return;
            }
            applyScenario(scenarios[name].data);
            closeScenarioModal();
            showMessage(`Scenario "${name}" loaded successfully!`, 'success');
        }
    } catch (error) {
        showMessage(`Failed to load scenario: ${error.message}`, 'error');
    }
}

/**
 * Deletes a specific scenario from appropriate storage location
 * Determines whether scenario is in old or new storage and deletes from correct location
 * Prompts for confirmation before deletion
 * Updates the management view and shows message
 * @param {string} name - Name of the scenario to delete
 */
function deleteScenario(name) {
    if (confirm(`Are you sure you want to delete "${name}"?`)) {
        try {
            const allScenarios = getAllScenarios();
            const scenario = allScenarios[name];
            
            if (scenario.isOldStorage) {
                // Delete from old storage
                const oldScenarios = getOldScenarios();
                delete oldScenarios[name];
                if (Object.keys(oldScenarios).length > 0) {
                    localStorage.setItem(OLD_STORAGE_KEY, JSON.stringify(oldScenarios));
                } else {
                    localStorage.removeItem(OLD_STORAGE_KEY);
                }
            } else {
                // Delete from new storage
                const scenarios = getSavedScenarios();
                delete scenarios[name];
                localStorage.setItem(STORAGE_KEY, JSON.stringify(scenarios));
            }
            
            manageScenarios();
            showMessage(`Scenario "${name}" deleted successfully.`, 'success');
        } catch (error) {
            showMessage(`Failed to delete scenario: ${error.message}`, 'error');
        }
    }
}

/**
 * Closes the scenario management modal dialog
 * No parameters
 */
function closeScenarioModal() {
    document.getElementById('scenarioModal').style.display = 'none';
}

// ============================================================================
// BULK OPERATIONS
// ============================================================================

/**
 * Deletes all scenarios that don't match SCENARIO_VERSION
 * Works across both old and new storage locations
 * Prompts for confirmation showing count and names of scenarios to delete
 * Removes old storage key if all old scenarios are deleted
 * Shows success/error message
 * No parameters
 */
function deleteIncompatibleScenarios() {
    const scenarios = getAllScenarios();
    const incompatibleNames = Object.keys(scenarios).filter(name => 
        !isCompatibleScenario(scenarios[name])
    );
    
    if (incompatibleNames.length === 0) {
        showMessage('No incompatible scenarios found.', 'warning');
        return;
    }
    
    if (confirm(`Delete ${incompatibleNames.length} incompatible scenario(s)?\n\n${incompatibleNames.join('\n')}`)) {
        try {
            const newScenarios = getSavedScenarios();
            const oldScenarios = getOldScenarios();
            
            // Delete from both storage locations
            incompatibleNames.forEach(name => {
                delete newScenarios[name];
                delete oldScenarios[name];
            });
            
            localStorage.setItem(STORAGE_KEY, JSON.stringify(newScenarios));
            
            // Only save old scenarios if there are any left
            if (Object.keys(oldScenarios).length > 0) {
                localStorage.setItem(OLD_STORAGE_KEY, JSON.stringify(oldScenarios));
            } else {
                localStorage.removeItem(OLD_STORAGE_KEY);
            }
            
            manageScenarios();
            showMessage(`${incompatibleNames.length} incompatible scenario(s) deleted.`, 'success');
        } catch (error) {
            showMessage(`Failed to delete scenarios: ${error.message}`, 'error');
        }
    }
}

/**
 * Completely removes OLD_STORAGE_KEY and all its scenarios
 * Prompts for confirmation showing count of scenarios to delete
 * Shows success/error message
 * No parameters
 */
function deleteOldStorageKey() {
    const oldScenarios = getOldScenarios();
    const oldCount = Object.keys(oldScenarios).length;
    
    if (oldCount === 0) {
        showMessage('No old storage scenarios found.', 'warning');
        return;
    }
    
    if (confirm(`This will permanently delete the old storage key and all ${oldCount} scenario(s) in it.\n\nAre you sure?`)) {
        try {
            localStorage.removeItem(OLD_STORAGE_KEY);
            manageScenarios();
            showMessage(`Old storage key removed (${oldCount} scenarios deleted).`, 'success');
        } catch (error) {
            showMessage(`Failed to remove old storage: ${error.message}`, 'error');
        }
    }
}

// ============================================================================
// IMPORT/EXPORT FUNCTIONS
// ============================================================================

/**
 * Exports a single scenario to JSON file
 * Works with scenarios from either storage location
 * Downloads file with scenario name as filename
 * Shows success or error message
 * @param {string} name - Name of the scenario to export
 */
function exportScenario(name) {
    try {
        const scenarios = getAllScenarios();
        const scenario = scenarios[name];
        
        const dataStr = JSON.stringify(scenario, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);
        
        const link = document.createElement('a');
        link.href = url;
        link.download = `${name}.json`;
        link.click();
        
        URL.revokeObjectURL(url);
        showMessage(`Scenario "${name}" exported successfully.`, 'success');
    } catch (error) {
        showMessage(`Failed to export scenario: ${error.message}`, 'error');
    }
}

/**
 * Opens file picker to import scenario from JSON file
 * Warns about version incompatibility if versions don't match
 * Prompts for scenario name (defaults to filename without extension)
 * Adds imported scenario to new storage location
 * Shows success, warning, or error message
 * No parameters
 */
function importScenario() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    
    input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        
        reader.onload = (event) => {
            try {
                const scenario = JSON.parse(event.target.result);
                
                if (scenario.version && scenario.version !== SCENARIO_VERSION) {
                    if (!confirm(`Warning: This scenario is from version ${scenario.version}, current version is ${SCENARIO_VERSION}.\n\nIt may not load correctly. Continue anyway?`)) {
                        showMessage('Import cancelled.', 'warning');
                        return;
                    }
                }
                
                const name = prompt('Enter name for imported scenario:', file.name.replace('.json', ''));
                
                if (name) {
                    const scenarios = getSavedScenarios();
                    scenarios[name] = scenario;
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(scenarios));
                    showMessage(`Scenario "${name}" imported successfully!`, 'success');
                } else {
                    showMessage('Import cancelled.', 'warning');
                }
            } catch (error) {
                showMessage(`Error importing scenario: ${error.message}`, 'error');
            }
        };
        
        reader.onerror = () => {
            showMessage('Failed to read file.', 'error');
        };
        
        reader.readAsText(file);
    };
    
    input.click();
}

/**
 * Exports all scenarios from new storage to single JSON file
 * Downloads with date-stamped filename (format: all-scenarios-YYYY-MM-DD.json)
 * Shows warning if no scenarios exist, otherwise shows success or error message
 * No parameters
 */
function exportAllScenarios() {
    try {
        const scenarios = getSavedScenarios();
        
        if (Object.keys(scenarios).length === 0) {
            showMessage('No scenarios to export.', 'warning');
            return;
        }
        
        const dataStr = JSON.stringify(scenarios, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);
        
        const link = document.createElement('a');
        link.href = url;
        link.download = `all-scenarios-${new Date().toISOString().split('T')[0]}.json`;
        link.click();
        
        URL.revokeObjectURL(url);
        showMessage(`All scenarios exported successfully.`, 'success');
    } catch (error) {
        showMessage(`Failed to export scenarios: ${error.message}`, 'error');
    }
}

// ============================================================================
// INITIALIZATION - Call on page load
// ============================================================================

window.addEventListener('DOMContentLoaded', function() {
    migrateOldScenarios();
});



// Auto-run tests when page loads (comment out if you don't want auto-run)
// window.addEventListener('DOMContentLoaded', runTests);
runTests?.();
runSimulation?.();
</script>
</body>
</html>